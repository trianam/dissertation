\documentclass[dissertation.tex]{subfiles}
\begin{document}
\chapter{Prerequisites}
\section{Splines and \bss}\label{sec:spline}
A \emph{spline} is a piecewise polynomial function with prescribed
regularity on its domain.

More formally we define a spline \cite{deboor}\cite{farin}
$$S:[a,b]\subset\mR\rightarrow\mR$$
as follows.
We have a partition of that interval defined by the \emph{breakpoints}
$$\tau = \{\tau_0,\dots,\tau_l\}$$
such that $a=\tau_0<\tau_1<\dots<\tau_{l-1}<\tau_l=b$ forming $l$
intervals
$$
I_i=
\begin{cases}
  [\tau_i,\tau_{i+1}) & \mbox{if } i=0,\dots,l-2\\
    [\tau_i,\tau_{i+1}] & \mbox{if } i=l-1\\
\end{cases}
$$
is possible to define the following spaces:
\paragraph{Piecewise polynomial functions space} $P_{m,\tau}$
is the space of the functions that are polynomials of maximum degree $m$
in each interval $I_i$ of the partition, formally:
\begin{multline*}
  P_{m,\tau}=\{f:[a,b]\rightarrow\mR\ \mid\ \exists p_0\dots
  p_{l-1}\in\Pi_m \ \text{such that}\\
  f(t)=p(t),\ \forall t\in I_i,\
  i=0\dots l-1\}
\end{multline*}
where $\Pi_m$ is the space of the polynomials of degree $\le m$. The
dimension of $P_{m,\tau}$ is $l(m+1)$ because the dimension of $\Pi_m$
is $m+1$.
\paragraph{Classic spline space}\index{Classic splines} $S_{m,\tau}$ is the space of
the piecewise polynomial functions that have continuity $C^{m-1}$ in
the junctions of the intervals, formally:
$$
S_{m,\tau}=P_{m,\tau}\cap C^{m-1}[a,b].
$$
The dimension of this space is $l(m+1)-(l-1)\cdot m\,=\,l+m$.
\paragraph{Generalized spline space}\index{Generalized splines} $S_{m,\tau,M}$ is the
space of piecewise polynomial function of degree $m$ with a prescribed
regularity at each breakpoint ranging from $-1$ to $m-1$. The
regularity is prescribed by the multiplicity vector
$$
M=\{m_1,\dots,m_{l-1}\},\quad m_i\in\mN,\quad 1\leq m_i\leq m+1
$$
as follows,
\begin{multline*}
  S_{m,\tau,M}=\{f:[a,b]\rightarrow\mR\ \mid\ \exists p_0\dots
  p_{l-1}\in\Pi_m \ \text{such that}\\
  f(t)=p(t),\ \forall t\in I_i,\
  i=0\dots l-1\ \text{and}\\
  p_{i-1}^{(j)}(\tau_i)=p_{i}^{(j)}(\tau_i),\ j=0,\dots,m-m_i,\ i=1,\dots,l-1\}.
\end{multline*}
The dimension of the space is equal to 
$$
l(m+1)-\sum_{i=1}^{l-1}(m-m_i+1)=m+\mu +1\qquad(\mu=\sum_{i=1}^{l-1}m_i)
$$

and is true that
$$
\Pi_m\subseteq S_{m,\tau}\subseteq S_{m,\tau,M}\subseteq P_{m,\tau},
$$
in particular:
\begin{itemize}
  \item if $m_i=1$ for all $i=1,\dots,l-1$, then
    $S_{m,\tau,M}=S_{m,\tau}$;
  \item if $m_i=m+1$ for all $i=1,\dots,l-1$, then
    $S_{m,\tau,M}=P_{m,\tau}$.
\end{itemize}

\subsection{Truncated-powers base for classic
  splines}\label{sec:truncpow}\index{Classic splines!truncated-powers base}
A truncated power $(t-\tau_i)_+^m$ is
defined by
$$
(t-\tau_i)_+^m=
\begin{cases}
  0,&\mbox{if}\quad t\leq\tau_i\\
  (t-\tau_i)^m, &\mbox{otherwise}.
\end{cases}
$$
Is possible to demonstrate that the functions
$$
g_i(t)=(t-\tau_i)_+^m)\ \in S_{m\tau},\quad i=1,\dots,l-1
$$
are linearly independents, and that
$$
1,t,t^2,\dots,t^m,(t-\tau_1)_+^m,\dots,(t-\tau_{l-1})_+^m
$$
form a base for the classic spline functions space \cite{deboor}. A
generic element
from this space can be expressed like
\begin{equation}\label{eq:classicSplineElement}
  S(t)=\sum_{i=0}^m c_i t^i\, +\, \sum_{j=1}^{l-1} d_i (t-\tau_j)_+^m.
\end{equation}

\subsection{\bss base for classic
  splines}\label{sec:bsplines}\index{\bss}\index{Classic splines!\bss base}
\emph{\bss} are a specific base wich can be alternatively used to
represent any generalized spline \cite{deboor}\cite{farin}. In this
paragraph we consider only the classic splines $S_{m,\tau}$ and not
the generalized splines $S_{m,\tau,M}$, in some textbook sometime is
considered the
\emph{order}$=m+1$.

For defining the \bss we need to extend the partition vector
$\tau=\{\tau_0,\cdots,\tau_l\}$ with $m$ knots to the left and $m$ to
the right, so we define a new vector
$$
T=\{t_0,\dots,t_{m-1},t_{m},\dots,t_{n+1},t_{n+2},\dots,t_{n+m+1}\}
$$
such that
\begin{equation*}
  t_0\leq\dots\leq t_{m-1}\leq \overmath{\equiv\tau_0\equiv a}{t_{m}}<\dots<\overmath{\equiv\tau_l\equiv b}{t_{n+1}}\leq t_{n+2}\leq\dots\leq t_{n+m+1}.    
\end{equation*}
$\tau$ have $l+1$ elements, so we can calculate the value of
$$
n=l+m-1,
$$
and the dimension of $S_{m,\tau}$ is
$$
l+m=n+1
$$
that is the number of necessary bases for the space.

The $n+1$ basis $N_{i,m+1}(t)$ of the \bss of degree $m$ for
$i=0,\dots,n$ are defined by the 
recursive formula:
\begin{align*}
  N_{i,1}(t) &=
  \begin{cases}
    1,\quad \mbox{if}\quad t_i\leq t<t_{i+1}\\
    0,\quad \mbox{otherwise}
  \end{cases}\\
  N_{i,r}(t) &= \omega_{i,r-1}(t)\cdot N_{i,r-1}(t)\ +\
  (1-\omega_{i+1,r-1}(t))\cdot N_{i+1,r-1}(t)\\
             &\pushright r=2,\dots,m+1
\end{align*}
where
$$
\omega_{i,r}(t) = \begin{cases}
  \frac{t-t_i}{t_{i+r}-t_i},&\mbox{if }t_i\neq t_{i+r}\\
  0, &\mbox{otherwise.}
\end{cases}
$$

The elements of the classic splines space can be expressed in the form
\begin{equation}\label{eq:bsplineElement}
  S(t)=\sum_{i=0}^nv_i N_{i,m+1}(t).
\end{equation}

\subsection{Spline curves}\index{Spline curves}
A parametric spline \emph{curve} $\ve{S}(t)$ is a curve in a certain
dimension $dim$ obtained applying a spline function to a set of points
in the same dimension $dim$
called \emph{control vertices}. We can apply the control vertices to a
spline expressed with the truncated powers as in
\cref{eq:classicSplineElement} replacing the coefficients $c_i$ and
$d_i$ with points
\begin{equation}\label{eq:classicSplineCurve}
  \ve{S}(t)=\sum_{i=0}^m \ve{c_i}\cdot t^i\, +\, \sum_{j=1}^{l-1} \ve{d_i}\cdot (t-\tau_j)_+^m  
\end{equation}

this form obtained with the truncated-powers base is not a practical
representation of a curve because
there isn't an intuitive correlation between the points
$\ve{c_i}$, $\ve{d_j}$ and the curve itself. Moreover
calculating $\ve{S}(t)$ is not a well conditioned problem
\cite{deboor}.
 For resolving those problems we
defined the \emph{\bss base} in \cref{sec:bsplines}.

We can apply control vertices to a spline expressed with the \bs
base as in \cref{eq:bsplineElement} replacing the coefficients $v_i$
with points
\begin{equation}\label{eq:bsplineCurve}
  \ve{S}(t)=\sum_{i=0}^n\ve{v_i}\cdot N_{i,m+1}(t).
\end{equation}
The representation of \cref{eq:bsplineCurve} is more convenient
respect to the one of 
\cref{eq:classicSplineCurve} because the curve $\ve{S}(t)$ roughly
follow the shape given by the points $\ve{v_i}$. Those points are
called \emph{control vertices} and the polygon defined by them is
called \emph{control polygon} and they can be used to control the
shape of the curve.

\section{\bss curves properties}\label{sec:bsplineProp}\index{\bss!properties}
In this section we describe some properties of \bs curves that we
used for the development of the project.

\subsection{Convex hull}\label{sec:convexHull}\index{\bss!convex hull}
A \bs curve $\ve{S}(t)$ of order $m$ defined by the control polygon
$\ve{v_0},\ve{v_1},\dots,\ve{v_n}$ is contained inside the union of the
convex hulls composed of $m+1$ vertices of the control polygon
\cite{farin}. If we
call $\conv(\ve{w_0},\ve{w_1},\dots,\ve{w_j})$ the convex hull of the
vertices $\ve{w_0},\ve{w_1},\dots,\ve{w_j}$ then we have
\begin{eqnarray*}
  C_0&=&\conv(\ve{v_0},\ve{v_1},\dots,\ve{v_{m}})\\
  C_1&=&\conv(\ve{v_1},\ve{v_2},\dots,\ve{v_{m+1}})\\
  &\cdots&\\
  C_{n-m}&=&\conv(\ve{v_{n-m}},\ve{v_{n-m+1}},\dots,\ve{v_{n}})\\
\end{eqnarray*}
and the area where $\ve{S}(t)$ is contained is
\begin{equation*}
  C=C_0\cup C_1\cup C_{n-m}
\end{equation*}
or in other words must be true
\begin{equation*}
  \ve{S}(t)\cap C =\ve{S}(t)\qquad \forall t\in[a,b]
\end{equation*}
whatever is the partition vector.

\begin{myfig}{Convex hull containing \bs of grade 2}{fig:convexHull}
  \begin{tikzpicture}
    \coordinate (a) at (0,0);
    \coordinate (b) at (0.5,1.7);
    \coordinate (c) at (2,3);
    \coordinate (d) at (4,3);
    \coordinate (e) at (5.5,1.7);
    \coordinate (f) at (6,0);
    
    \path[convexHull] (a) -- (b) -- (c) -- (a);
    \path[convexHull] (b) -- (c) -- (d) -- (b);
    \path[convexHull] (c) -- (d) -- (e) -- (c);
    \path[convexHull] (d) -- (e) -- (f) -- (d);
    
    \draw[convexHullBord] (a) -- (c);
    \draw[convexHullBord] (b) -- (d);
    \draw[convexHullBord] (c) -- (e);
    \draw[convexHullBord] (d) -- (f);
    
    \draw[controlPoly] (a) -- (b) -- (c) -- (d) -- (e) -- (f);
    \foreach \p in {a,b,c,d,e,f}
    \filldraw[controlVert] (\p) circle (2pt);

    \node[above left] at (a) {$\ve{v_0}$};
    \node[above left] at (b) {$\ve{v_1}$};
    \node[above] at (c) {$\ve{v_2}$};
    \node[above] at (d) {$\ve{v_3}$};
    \node[above right] at (e) {$\ve{v_4}$};
    \node[above right] at (f) {$\ve{v_5}$};
  \end{tikzpicture}  
\end{myfig}
On \cref{fig:convexHull} is visible an example of a control polygon
and the surface where a quadratic \bs applied to
it can be contained. Note that the convex hull property holds also in
3-dimensional
space - i.e. a quadratic \bs in 3-dimensional space is contained
inside a flat surface composed by the union of triangles. From grade 3
the area where $\ve{S}(t)$ can be contained is not anymore plane
because is composed of union of solid polyhedrons.

\subsection{Smoothness}\label{sec:smoothness}\index{Smoothness}\index{\bss!smoothness}
The concept of smoothness consist of identifying what is the number of
possible derivatives of the function such that the function is
continue. A function $f$ that is not continue is said to be of class
$C^{-1}$, a function that is continue until derivative $d$ is said to
be of class $C^d$, a function that is always continue for every
derivative is said to be of class $C^\infty$.

A \bs curve of degree $m$ with $n$ control vertices consists of
$n-m$ polynomial segments, one for each 
interval 
\begin{equation*}
[t_i,t_{i+1}]\qquad i=m,\dots,n+1  
\end{equation*}
this mean that $\ve{S}(t)$ is $C^\infty$ for
\begin{equation*}
t\in(t_i,t_{i+1})\qquad i=m,\dots,n+1.
\end{equation*}
Note that, if we use generalized \bs curves, an interval
$[t_i,t_{i+1}]$ can also be of dimension $1$ if
we have a knot multiplicity $>1$, in
such case there isn't a polynomial segment.
On every breakpoint $t_i$ with $i=1,\dots,n+m-1$ we have that the curve has
smoothness $C^{m-1}$
and, if we use generalized \bs curves, smoothness $C^{m-r}$ where $r$ is the
multiplicity of the knot \cite{farin}.

In our project we don't use generalized \bs curves, so globally a
curve of degree $m$ have smoothness
\begin{equation*}
  C^{m-1}.
\end{equation*}

\subsection{Aligned vertices}\index{\bss!aligned vertices}\label{sec:alignedVertices}
In our project we dealt sometimes with some problems whose solution
involved aligning two or more control vertices of the curve. In this
section we analyze the effects on the curve of aligning vertices.

We can have the following situations:
\paragraph{$m$ aligned control vertices}
If $m$ control vertices $v_i,\dots,v_{i+m-1}$ of control polygon are on the same line then
the curve $\ve{S}(t)$ touch the segment joining those vertices.

\paragraph{$m+1$ aligned control vertices}
If $m+1$ control vertices $v_i,\dots,v_{i+m}$ of control polygon are on the same line then
the curve $\ve{S}(t)$ lay on the segment joining those vertices.

\subsection{End point interpolation}\index{\bss!end point interpolation}\label{sec:clamped}
In general a \bs curve with control vertices
\begin{equation*}
  \ve{v_0}, \dots, \ve{v_n}
\end{equation*}
and partition vector
\begin{equation*}
  T=\{t_0,\dots,t_{m-1},t_{m},\dots,t_{n+1},t_{n+2},\dots,t_{n+m+1}\}
\end{equation*}
don't necessarily interpolate any control vertex $v_i$, neither the
first and the last one. But we are
interested in using \bs for representing paths from one point to
another, so should be a nice feature to have that the curve defined in
the domain $[a,b]$ is shaped such that
\begin{equation}\label{eq:clamped}
  \begin{cases}
    \ve{S}(t)=\ve{v_0}& \text{for } t=a\\
    \ve{S}(t)=\ve{v_n}& \text{for } t=b.
  \end{cases}
\end{equation}

We can obtain the conditions of \cref{eq:clamped} if we impose on the
extended partition vector $T$:
\begin{equation*}
  t_0=\dots= t_{m-1}= \overmath{\equiv a}{t_{m}}<\dots<
\overmath{\equiv b}{t_{n+1}}= t_{n+2}=\dots= t_{n+m+1}
\end{equation*}
in other words we want
\begin{equation*}
  T=\{\overbrace{a,\dots,a}^m,t_{m+1},\dots,t_{n},\overbrace{b,\dots,b}^m\}
\end{equation*}

\subsection{Curvature and
  torsion}\index{Curvature and torsion}\index{\bss!curvature and torsion}
We are interested in comparing the characteristics different curves,
we need to recognize if a certain curve is a \emph{good} or a
\emph{bad} curve. one factor that characterize a certain curve can 
be the smoothness of the curve (\cref{sec:smoothness}) - i.e. a $C^3$ curve
is better than a $C^2$ curve - but this isn't
enough for comparing curves with same degree (and smoothness). For
accomplish that we
introduce on this section the concepts of \emph{curvature} and
\emph{torsion} \cite{docarmo}. Both are quantities defined on generic
parametric curves for each value of the parameter.

For a generic parametric curve $\ve{S}(u)$ defined for $u\in[a,b]$ we
have that the curvature is defined as
\begin{equation}
  \label{eq:curvature}
  \kappa(u) = \frac{\norm{\dot{\ve{S}}(u)\wedge\ddot{\ve{S}}(u)}}{{\norm{\dot{\ve{S}}(u)}}^3}
\end{equation}
and the torsion is defined as
\begin{equation}
  \label{eq:torsion}
  \tau(u) =
  \frac{\det\left[\dot{\ve{S}}(u),\ddot{\ve{S}}(u),\dddot{\ve{S}}(u)\right]}{\norm{\dot{\ve{S}}(u)\wedge\ddot{\ve{S}}(u)}}
  = \frac{\left(\dot{\ve{S}}(u)\wedge\ddot{\ve{S}}(u)\right)\cdot\dddot{\ve{S}}(u)}{\norm{\dot{\ve{S}}(u)\wedge\ddot{\ve{S}}(u)}}
\end{equation}
where $\wedge$ is the vector product and
\begin{equation*}
  \dot{\ve{S}}(u) = \frac{\md}{\md u} \ve{S}(u)=\left[
    \begin{array}{c}
      \frac{\md}{\md u} X(u)\\
      \frac{\md}{\md u} Y(u)\\
      \frac{\md}{\md u} Z(u)
    \end{array}
    \right].
\end{equation*}

\cref{eq:curvature} and \cref{eq:torsion} describe completely the
behavior of $\ve{S}(u)$ locally for each value of $u$. Curvature and
torsion have also a geometric interpretation: for each value $\tilde{u}$ of
the parameter $u$, the inverse $\frac{1}{\kappa(\tilde{u})}$ of the
curvature is the radius of curvature on the point defined by
$\ve{S}(\tilde{u})$ - i.e. the radius of the 
osculating circle tangent to the point that lie on the plane where the
curve is bending and
that is situated on the inner side of the turn - $\tau(\tilde{u})$ indicate
(if $\kappa(\tilde{u})\neq 0$) how sharply is rotating the plane where
the curve lie.

The value of $\kappa(u)$ can be only positive, $\tau(u)$ can be
positive and negative. Also we have that:
\begin{itemize}
\item for $C^{\leq 0}$ curves $\kappa(u)$ and $\tau(u)$ are not defined;
\item for $C^1$ curves $\kappa(u)$ is defined but not continue and
  $\tau(u)$ is not defined;
\item for $C^2$ curves $\kappa(u)$ is defined and continue and
  $\tau(u)$ is defined but not continue;
\item for $C^{\geq 3}$ curves $\kappa(u)$ is defined and continue and
  $\tau(u)$ is defined and continue.
\end{itemize}

Two curves of same smoothness can be compared using the plots of
curvature and torsion, in general a curve that have lower peaks of
$\kappa(u)$ and $\tau(u)$ are better respect to curves that have
higher peaks.

\section{Voronoi Diagrams}\label{sec:voronoi}\index{\acf{VD}}
On this section we introduce an important structure that we used in
our project. \ac{VD} \cite{deberg} provide a method for creating a
partition of the
space using distances from a set of input points called
\emph{sites}. Formally we have a set
\begin{equation*}
  S=\{\ve{s_0},\ve{s_1},\dots,\ve{s_n}\} \subset \mE^d
\end{equation*}
Of $n$ sites in the euclidean space of dimension $d$, and we build a
set of Voronoi \emph{cells}
\begin{equation*}
  Vor(S)=\{V(\ve{s_0}),\dots,V(\ve{s_n})\}\subset 2^{\mE^d}
\end{equation*}
such that each cell, one for each site $\ve{s_i}$, is the set
\begin{equation*}
  V(\ve{\ve{s_i}})=\{\ve{p}\in\mE^d\ :\
  \norm{\ve{p}-\ve{s_i}}<\norm{\ve{p}-\ve{s_j}}\ \forall \ve{s_j}\neq\ve{s_i}\}
\end{equation*}
of the points of the space such that are nearer to $\ve{s_i}$ respect
to the other sites.

\image{voronoi.eps}{Example of \ac{VD}.}{fig:voronoi}


The most important algorithm for calculating \ac{VD} is the
\emph{sweeping line} algorithm that build the diagram in $\bigO(n\log
n)$ and it is optimal. The algorithm involve building $Vor(S)$
incrementally while sweeping the space, see \cite{deberg} and
\cite{fortune} for
details.

One property of \ac{VD} is that $V(\ve{s_i})$ can be closed area or an
open area - i.e. the edges of the cells can be infinite - is important
to deal with this fact if we want to interpret $Vor(S)$ as the graph of
vertexes and edges of the cells (it will have edges that go to
infinite), we call such graph $G(Vor(S))$.

Another property is that if we have $d+1$ sites $\ve{s_0'},\dots,\ve{s_d'}$ that lay on the
surface of a $(d-1)$-sphere\footnote{A circumference in $2$-dimensional
  space, a sphere in $3$-dimensional space, an hypersphere in
  $n$-dimensional space with $n\ge 3$.} that don't have any other site on
the interior, then the center point of the $(d-1)$-sphere is the
vertex shared between the $d+1$ cells $V(\ve{s_0'}),\dots,V(\ve{s_d'})$
and nothing else. This is not true for less than $d+1$ sites on a
$(d-1)$-sphere because they are not enough to define it univocally,
but is possible to have $n>d+1$ sites on a $(d-1)$-sphere, on that
case the center of the $(d-1)$-sphere is the shared vertex of the
cells corresponding to the $n$ sites. This is important for reasoning
about the topography of $G(Vor(S))$ because if we allow more than
$d+1$ sites on a $(d-1)$-sphere then the maximum degree
$\Delta(G(Vor(S)))$ of the graph can be arbitrarily big (until the
number of vertices). However the fact that we work with real scenarios -
i.e. with coordinates in $\mE^d$ - legitimize the restriction of not
allowing more than $d+1$ sites on an $(d-1)$-sphere, limiting
$\Delta(G(Vor(S)))$ to $d+1$.

\section{Statistical methods}\label{sec:statisticalMethods}
On this section we make a short introduction to \ac{MCM}
\cite{metropolis}\cite{sobol}\cite{newman} and \ac{SA} \cite{kirkpatrick}\cite{ho},
two statistical methods for calculating unknown quantities and finding
minimum of functions. Also we introduce \ac{LR} \cite{benjamin} a
method for transforming a constrained optimization problem in an
unconstrained optimization problem increasing the state space
dimension.
\subsection{Notes on probabilities}
\subsubsection{\ac{PE}}
For a random variable $X$ normally distributed with
\begin{itemize}
\item mean $\mu$;
\item variance $\sigma$;
\end{itemize}
for
\begin{equation*}
  r=0.6745\sigma
\end{equation*}
we have that
\begin{eqnarray*}
  \prob{\mu-r<X<\mu+r} &=& 0.5\\
  \prob{\abs{X-\mu}<r} &=& 0.5\\
  \prob{\abs{X-\mu}>r} &=& 0.5.
\end{eqnarray*}
So values of $X$ that deviate from $\mu$ approximately by $r$ have the
same probability, and $r$ identifies the most \ac{PE} in a
normal distribution.
\subsubsection{\acf{PCLT}}
Consider $N$ independent and identically distributed random variables
$X_1,X_2,\dots,X_N$, with same mean and same variance
\begin{eqnarray*}
  \expected{X_1}=\expected{X_2}=\dots=\expected{X_N}&=&m\\
  \variance{X_1}=\variance{X_2}=\dots=\variance{X_N}&=&b^2.
\end{eqnarray*}

Consider the sum of those random variables:
\begin{equation*}
  Y = X_1+X_2+\cdots+X_N
\end{equation*}
we have that
\begin{eqnarray*}
  \expected{Y}&=&\expected{X_1+X_2+\cdots+X_N}=Nm\\
  \variance{Y}&=&\variance{X_1+X_2+\cdots+X_N}=Nb^2.
\end{eqnarray*}

Consider now a normally distributed random variable $Z$ with
parameters:
\begin{eqnarray*}
  \mu&=&Nm\\
  \sigma&=&b\sqrt{N}
\end{eqnarray*}
with \ac{PDF} $p_Z(x)$.

The \emph{\ac{PCLT}} affirm that for $N$ big
enough, and for every interval $(x_1,x_2)$:
\begin{equation}\label{eq:tcl}
  \prob{x_1<Y<x_2}\approx\int_{x_1}^{x_2}p_Z(x) \md x.
\end{equation}
So the sum of an elevate number of identically distributed random
variables is a normal distribution with mean $Nm$ and variance $Nb^2$
equals to mean and variance of $Y=X_1+X_2+\dots+X_N$ - even if
$X_1,X_2,\dots,X_N$ aren't normally distributed.

\subsection{\acf{MCM}}\index{Monte Carlo Method}
Suppose that you need to calculate an unknown quantity $m$, you need
to find a random variable $X$ such that:
\begin{equation*}
  \expected{X} = m.
\end{equation*}
If you have such distribution with variance:
\begin{equation*}
  \variance{X} = b^2
\end{equation*}
is possible to formalize the following passages.

Consider $N$ random variables $X_1,X_2,\dots,X_N$ that have
distribution identical to the distribution of $X$. For the \ac{PCLT}
\cref{eq:tcl} we have that, for $N$ big enough, that the sum
\begin{equation*}
  Y=X_1+X_2+\cdots+X_N
\end{equation*}
is normally distributed with parameters
\begin{eqnarray*}
  \mu &=& Nm\\
  \sigma&=&b\sqrt{N}.
\end{eqnarray*}

For the \emph{three sigma rule} we have that:
\begin{eqnarray*}
  \prob{\mu-3\sigma < Y <\mu +3\sigma}&\approx& 0.997\\
  \prob{Nm-3b\sqrt{N} < Y < Nm+3b\sqrt{N}}&\approx& 0.997
\end{eqnarray*}
dividing by $N$:
\begin{eqnarray*}
  \prob{m-\frac{3b}{\sqrt{N}} < \frac{Y}{N} <
    m+\frac{3b}{\sqrt{N}}}&\approx& 0.997\\
  \prob{\abs{\frac{Y}{N}-m} <\frac{3b}{\sqrt{N}}}&\approx& 0.997
\end{eqnarray*}
and so:
\begin{equation}\label{eq:mc}
  \prob{\abs{\frac{1}{N}\sum_{i=1}^NX_i-m} <\frac{3b}{\sqrt{N}}}\approx 0.997.
\end{equation}

\Cref{eq:mc} assert that, if you extract a sample for each random
variable $X_i$, the arithmetic mean of those values is approximately
equal to $m$. Moreover the error of such approximation is equal to
$3b/\sqrt{N}$, that tend to $0$ increasing $N$. Is possible to further
reduce the uncertainty ($1-0.997=0.003$) increasing the number $k$ of
sigma used for the
approximation and evaluating the error $kb/\sqrt{N}$.

In reality, since the random variables $X_i$ have the same
distribution of $X$, is enough to extract $N$ samples from $X$ for
reaching to the same conclusions.

The \ac{MCM} is constituted by the following procedure, to be adapted
according to the problems:
\begin{enumerate}
\item find the distribution $X$ with mean the desired quantity $m$ and
  variance $b^2$;
\item extract $N$ samples from $X$, with $N$ big enough to have an
  error small as desired;
\item the arithmetic mean of those $N$ samples is the approximation of
  the desired value $m$.
\end{enumerate}
Basically we moved the problem from \emph{calculate $m$} to \emph{find
  the distribution $X$}, or anyway the $N$ samples distributed
accordingly to $X$.

If we want to characterize more in detail the error committed taking
$N$ samples, we can recur to \ac{PE}. If we set $k=0.6745$ then we
have that
\begin{equation*}
  \prob{\abs{\frac{1}{N}\sum_{i=1}^NX_i-m} <\frac{0.6745\cdot b}{\sqrt{N}}}\approx 0.5
\end{equation*}
and so
\begin{equation*}
  r_N = \frac{0.6745\cdot b}{\sqrt{N}}
\end{equation*}
indicate how deviate in average the value $\frac{1}{N}\sum_{i=1}^NX_i$
from the desired value $m$. Such value characterize the absolute error
\begin{equation*}
\abs{\frac{1}{N}\sum_{i=1}^NX_i-m}  
\end{equation*}
committed taking $N$ samples.

\ac{MCM} is useful for simulate events that have an high degree of
uncertainty in the inputs or an high degree of liberty in the
state. For instance integrating numerically a function with many
dimensions or \ac{SA}.

\subsection{\acf{SA}}\index{\acf{SA}}
The \ac{SA} is a method used for finding the global optimum - i.e. the
maximum or the minimum - of a function. It is inspired by a method
used in metallurgy that consists in heating and then cooling slowly a
material for augmenting the dimensions of the crystals and improving
the chemico-physical properties. The function to optimize can be
defined in a multiple-dimensional space.

\subsubsection{Statistical thermodynamic}
For describing the base principles of statistical thermodynamic we
consider an example system. In a one-dimensional lattice every point
is a particle with a value of spin that can be \emph{up} or
\emph{down}. If the lattice have $N$ points then the system can be in
$2^N$ different configurations, for each one of those configurations
corresponds a value of energy, for instance:
\begin{equation*}
  E=B(n_+-n_-)
\end{equation*}
where $B$ is some constant, $n_+$ is the number of particles with spin
\emph{up} and $n_-$ is the number of particles with spin \emph{down}.

The probability $P(\sigma)$ of finding the system in a certain
configuration $\sigma$ is given by the distribution of
\emph{Boltzmann-Gibbs}:
\begin{equation}\label{eq:distBoltz}
  P(\sigma) = C \me^{-E_\sigma/T}
\end{equation}
where $E_\sigma$ is the energy of the configuration, $T$ is the
temperature\footnote{The real Boltzmann-Gibbs distribution is
  $P(\sigma) = C \me^{-E_\sigma/kT}$ where $k$ is the \emph{Boltzmann
    constant} and $T$ is the thermodynamic temperature, but for the
  example the temperature is a parameter not correlated to the
  physical world, so is possible to ignore $k$.} and $C$ is a
normalization constant.

The average energy of the system is then:
\begin{eqnarray*}
  \bar{E} &=& \frac{\sum_\sigma E_\sigma P(\sigma)}{\sum_\sigma
    P(\sigma)}\\
  &=& \frac{\sum_\sigma E_\sigma \me^{-E_\sigma/T}}{\sum_\sigma \me^{-E_\sigma/T}}.
\end{eqnarray*}
Compute the value of $\bar{E}$ can be difficult with an high number of
states, but is possible to create a \ac{MCM} that simulate the random
fluctuation between the states such that the distribution given by
\cref{eq:distBoltz} is respected. Starting from an arbitrary initial
configuration, after a certain number of \emph{Monte Carlo trials},
the method converge to the equilibrium status $\bar{E}$ and continue
to fluctuate around it. \ac{SA} is a method of this kind.

\subsubsection{\acf{SA} algorithm}\index{Simulated annealing!algorithm}
\ac{SA} operates on a system starting from a certain initial state
$s_0$, then execute a series of iterations where is evaluated a
neighbour of the state and, with a certain distribution of
probability, the system is moved in the new state or not.

\begin{algo}{\acf{SA}}{alg:sa}
  \Function{anneal}{$s_0$}
  \State $s\Ass s_0$
  \For{$k\Ass 0,kMax$}
  \State $T\Ass temp(\frac{k}{kMax})$
  \State $sNew\Ass neighbour(s)$
  \If{$uniform(0,1)<P(E(s), E(sNew), T)$}
  \State $s\Ass sNew$
  \EndIf
  \EndFor
  \State\Return $s$
  \EndFunction
\end{algo}
A possible algorithm for a \ac{SA} method is \cref{alg:sa}. $s_0$ is
the initial state; $temp$ is the function that assign a
temperature based on the current iteration number such that for low
$k$ the returned temperature is high and for high $k$ the returned temperature
is low; $neighbour$ is the function that return a random neighbour of
the current state; $uniform$ returns an uniformly-randomly chosen
number in $[0,1]$; $P$ is the distribution of accepting probability,
that depends on the energy of the current state, on the energy of the
neighbour, and on the current temperature. In case of acceptation the
neighbour become the current state and the process continue.

The relation with the statistical thermodynamic is that $P$ is chosen
such that holds\footnote{A similar distribution is enough.}
\cref{eq:distBoltz}, moreover $temp$ returns decreasing values of
temperature with the succession of iterations, this is why the
comparison with the metallurgy annealing.

Initially $P$ was chosen such that
\begin{equation*}
  P(E(s), E(sNew), T)=
  \begin{cases}
    1,& \text{if }E(sNew)<E(s)\\
    \me^{-(E(sNew)-E(s))/T},& \text{otherwise}
  \end{cases}
\end{equation*}
but this isn't strictly necessary for developing a \ac{SA} method.

\subsection{\acf{LR}}\label{sec:lagrangianRelaxation}
A general constrained discrete optimization problem can be expressed in
the form:
\begin{equation}\label[problem]{eq:opt}
\begin{aligned}
& \underset{x}{\text{minimize}}
& & f(x) \\
& \text{subject to}
& & g(x)=0.
\end{aligned}
\end{equation}
Where $x$ is the state of the system in a discrete space $X$, $f(x)$
is the function to
minimize, and $g(x)=0$ is the constraint. the functions can also be
in a multidimensional discrete space, in that case the $x$ is a vector
$\ve{x}=(x_1,\dots,x_n)$ of variables.

For solving this class
of problem is necessary a \emph{Lagrange relaxation} method, that
augment the variable space $X$ by a \emph{Lagrange multiplier} space
$\Lambda$ of dimension equal to the number of constraints - one in the
\cref{eq:opt}.

The \emph{generalized discrete Lagrangian
  function} corresponding to the \cref{eq:opt} is:
\begin{equation}\label{eq:lagrangianFun}
  L_d(x,\lambda)=f(x)+\lambda H(g(x)).
\end{equation}
Where $\lambda$ is a variable in $\Lambda$, and if the dimension of
$\Lambda$ is more than one $\lambda$ must be transposed in
~\cref{eq:lagrangianFun}; $H(x)$ is a non negative function
with the property that $H(0)=0$, the purpose is to transform $g(x)$ in
a non negative function - if $g(x)$ isn't already not negative - for
instance can be $H(g(x))=|g(x)|$ or $H(g(x))=g^2(x)$.

Under the previous assumptions the set of \emph{local minima}
in \cref{eq:opt} - that respect the constraints -  coincide
with the set of \emph{discrete saddle point}
in the augmented space. A point $(x^*,\lambda^*)$ is a discrete saddle
point if:
\begin{equation*}
  L_d(x^*,\lambda)\leq L_d(x^*,\lambda^*)\leq L_d(x,\lambda^*)
\end{equation*}
for all $x\in\mathcal{N}(x^*)$ and for all $\lambda\in\Lambda$, where
$\mathcal{N}(x^*)$ is the set of all neighbours of $x^*$.

For resolving the optimization \cref{eq:opt} is necessary to
calculate all the discrete saddle points $(x^*,\lambda^*)$ using some
optimization method (i.e. simulated annealing) on the surface
represented by
\cref{eq:lagrangianFun}, and then choose
the one that minimize $f(x^*)$. $x^*$ is then the desired minimum.

\section{Intersections in space}\label{sec:intersections}
In the project we need to deal with three kind of collision detection
methods in 3-dimension euclidean space:
\begin{itemize}
\item we need to check if a point is inside or outside
  of a convex polyhedron;
\item we need to check if a segment intersect the
  surface of a triangle;
\item and we need to check if the surface of a
  triangle intersect the surface of another triangle.
\end{itemize}

\subsection{Point inside convex polyhedron in 3-d space}
For testing if a point $\ve{p}$ is inside a convex polyhedron $V$ with
vertices $\ve{v_1},\ve{v_2},\dots,\ve{v_n}$ we used a method that rely
on convex hulls \cite{deberg}\cite{schneider}.

\begin{algo}{Check if point $\ve{p}$ is inside convex polyhedron $V$}{alg:pointInPoly}
  \Function{isPointInPolyhedron}{$\ve{p}$, $V$}
  \State $inside\Ass\True$
  \State $C\Ass convexHull([\ve{p},\ve{v_1},\ve{v_2},\dots,\ve{v_n}])$
  \ForAll{$\ve{c}\in C$}\label{ln:pointInPolyFor}
  \If{$c=p$}
  \State $inside\Ass\False$
  \State \Break
  \EndIf
  \EndFor
  \State\Return $inside$
  \EndFunction
\end{algo}
As in the \cref{alg:pointInPoly} first we build the convex hull of all
the vertices of $V$ plus the point $\ve{p}$, then we check if $\ve{p}$
is on the convex hull or not. If $\ve{p}$ is on the convex hull that
means that $\ve{p}$ is external\footnote{Or $\ve{p}$ coincides with a
  vertex of $V$.} to $V$ because we have extended the convex hull
formed by the vertices of $V$. Otherwise this means that $\ve{p}$ is
inside $V$.

The cost of this algorithm is
\begin{equation*}
  \bigO(n\log n)
\end{equation*}
where $n$ is the number of vertices of $V$, because the cost for
constructing the convex hull is \cite{deberg} $\bigO(n\log n)$, and
then we have another negligible term $\bigO(n)$ for the cycle on \cref{ln:pointInPolyFor}.

\subsection{Segment-triangle in 3-d space}\label{sec:intersectionST}
We need to deal with the intersection between a segment
$S=\overline{\ve{a_2}\ve{b_2}}$ and a triangle
$T=\triangle\ve{a_1}\ve{b_1}\ve{c_1}$. $S$ and $T$ can be in one of
the cases:
\begin{enumerate}[label=\textbf{case \arabic*}]
\item\label[void]{en:ist:nc:ni} $S$ and $T$ don't intersect and the plane containing
  $T$ is not in the sheaf of planes generated by the line
  containing $S$;
\item\label[void]{en:ist:c:ni} $S$ and $T$ don't intersect and the plane containing
  $T$ is in the sheaf of planes generated by the line
  containing $S$;
\item\label[void]{en:ist:nc:i} $S$ and $T$ intersect in only one point and the plane containing
  $T$ is not in the sheaf of planes generated by the line
  containing $S$;
\item\label[void]{en:ist:c:i} $S$ and $T$ intersect in one or infinite points and the plane
  containing $T$ is in the sheaf of planes generated by the line
  containing $S$.
\end{enumerate}
The discriminant between the cases is that if $S$ and $T$ are
intersecting and if $S$ and $T$ are coplanar. The cases are resumed in
\cref{tab:intersectSegmentTriang}.
\begin{table}
  \centering
  \begin{tabular}{l|cc}
    &not coplanar&coplanar\\
    \hline
    not intersect& \cref{en:ist:nc:ni} & \cref{en:ist:c:ni}\\
    intersect& \cref{en:ist:nc:i} & \cref{en:ist:c:i}\\
  \end{tabular}
  \caption{Relations between $S$ and $T$}
  \label{tab:intersectSegmentTriang}
\end{table}

\begin{myfig}{Example intersection between a segment
    $\overline{\ve{a_2}\ve{b_2}}$ and a triangle $\triangle \ve{a_1}\ve{b_1}\ve{c_1}$.}{fig:segmentTriangleIntersection}
  \begin{tikzpicture}
    \coordinate (A1) at (0,0);
    \coordinate (B1) at (4,5);
    \coordinate (C1) at (8,1);

    \coordinate (cut1) at (barycentric cs:A1=0.8,B1=0.,C1=0.2);
    \coordinate (cut2) at (barycentric cs:A1=0.,B1=0.8,C1=0.2);

    \coordinate (A2) at (2,5);    
    \coordinate (B2) at (4.5,1.5);

    \coordinate (X) at (intersection of cut1--cut2 and B2--A2);

    \draw[poly] (A1) -- (C1) -- (B1) -- (A1);
    \draw[poly] (A2) -- (X);
    \draw[polyTract] (B2) -- (X);

    \foreach \p in {A1,B1,C1,A2,B2}
    \filldraw[vertex] (\p) circle (2pt);

    \filldraw[intersection] (X) circle (2pt);

    \node[below=0.5em] at (A1) {$\ve{a_1}$};
    \node[above=0.5em] at (B1) {$\ve{b_1}$};
    \node[below=0.5em] at (C1) {$\ve{c_1}$};
    \node[above=0.5em] at (A2) {$\ve{a_2}$};
    \node[right=0.5em] at (B2) {$\ve{b_2}$};
    \node[right=0.2em] at (X) {$\ve{x}$};
  \end{tikzpicture}
\end{myfig}
In \cref{fig:segmentTriangleIntersection} is visible a
\cref{en:ist:nc:i} relation where there is intersection in only one
point $\ve{x}$. For calculating if there is intersection we can solve
four equation in four unknowns \cite{schneider} where we look for
$\ve{x}$ searching a point that is a convex linear
combination of $\ve{a_2}$ and $\ve{b_2}$ and at the same time a convex
linear combination of $\ve{a_1}$,
$\ve{b_1}$ and $\ve{c_1}$. In other words when there is a collision,
then there is a solution for the unknowns
$\alpha$, $\beta$, $\gamma$, $\delta$, $\zeta$ of the system
\begin{equation}\label[system]{eq:segmentTriangleIntersection1}
  \begin{cases}
    \alpha \ve{a_2} + \beta\ve{b_2}=\gamma\ve{a_1}+\delta\ve{b_1}+\zeta\ve{c_1} \\
    \alpha + \beta = 1\\
    \gamma + \delta +\zeta=1
  \end{cases}
\end{equation}
with the further conditions
\begin{equation}\label[system]{eq:segmentTriangleIntersection1c}
  \begin{cases}
    \alpha \ge 0\\
    \beta \ge 0\\
    \gamma \ge 0\\
    \delta \ge 0\\
    \zeta \ge 0.
  \end{cases}
\end{equation}
Note that the first equation of
\cref{eq:segmentTriangleIntersection1} have vectorial coefficients
$\ve{a_2}$, $\ve{b_2}$, $\ve{a_1}$, $\ve{b_1}$, $\ve{c_1}$, so the
system is of five unknowns in five equations. If
\Cref{eq:segmentTriangleIntersection1} have one solution then we are
on \cref{en:ist:nc:ni} or \cref{en:ist:nc:i}, if have infinite
solution then we are on \cref{en:ist:c:ni} or \cref{en:ist:c:i}, if
don't have solution then $S$ or $T$ are degenerated. If
\cref{eq:segmentTriangleIntersection1c} is satisfied for the solution(s)
of \cref{eq:segmentTriangleIntersection1} then we are in
\cref{en:ist:nc:i} or \cref{en:ist:c:i}, if is not satisfied then we
are in \cref{en:ist:nc:ni} or \cref{en:ist:c:ni}.

We are interested in finding only \cref{en:ist:nc:i} collisions because for
simplicity we consider the special case of a segment that lay on the
surface of a triangle as not colliding with it, and for coherence we
restrict the conditions of \cref{eq:segmentTriangleIntersection1c} to
\begin{equation}
  \begin{cases}
    \alpha > 0\\
    \beta > 0\\
    \gamma > 0\\
    \delta > 0\\
    \zeta > 0.
  \end{cases}
\end{equation}

\Cref{eq:segmentTriangleIntersection1} can be simplified in the three
equations 
\begin{equation}\label[system]{eq:segmentTriangleIntersection2}
  \begin{cases}
    \alpha \ve{a_2} + (1-\alpha)\ve{b_2}=\beta\ve{a_1}+\gamma\ve{b_1}+(1-(\beta+\gamma))\ve{c_1} \\
  \end{cases}
\end{equation}
in the unknowns $\alpha$, $\beta$ and $\gamma$ with the relative conditions
\begin{equation}\label[system]{eq:segmentTriangleIntersection2c}
  \begin{cases}
    \alpha > 0\\
    \alpha < 1\\
    \beta > 0\\
    \gamma > 0\\
    \beta+\gamma<1.
  \end{cases}
\end{equation}

\begin{algo}{Find intersection between segment $S$ and triangle $T$}{alg:intersectSegmentTriangle}
  \Function{intersect}{$S, T$}
  \State $intersect\Ass\False$
  \State $coordinates\Ass\emptyset$
  \If{$(\alpha,\beta,\gamma)\Ass
    solve($\cref{eq:segmentTriangleIntersection2}$)$}\label{ln:intersectSegmentTriangleIf}
  \If{$satisfy($\cref{eq:segmentTriangleIntersection2c}$)$}
  \State $intersect\Ass\True$
  \State $coordinates\Ass(\beta, \gamma, 1-(\beta+\gamma))$
  \EndIf
  \EndIf
  \State\Return $(intersect, coordinates)$
  \EndFunction
\end{algo}
The \cref{alg:intersectSegmentTriangle} for calculating the
intersection consists basically on solve
\cref{eq:segmentTriangleIntersection2} with the parameters $\ve{a_2}$,
$\ve{b_2}$, $\ve{a_1}$, $\ve{b_1}$ and $\ve{c_1}$ from $S$ and $T$;
and then on checking if the solution is admissible. The condition of
\cref{ln:intersectSegmentTriangleIf} is $\True$ if
\cref{eq:segmentTriangleIntersection2} have solution and if that
is unique.

We have also the positive secondary effect that from the solution
$(\alpha,\beta,\gamma)$ of \cref{eq:segmentTriangleIntersection2} we
can extract the barycentric coordinates $(\beta, \gamma,
1-(\beta+\gamma))$ of the intersection point $\ve{x}$ on the system of
the vertices $\ve{a_1}$, $\ve{b_1}$, $\ve{c_1}$ of $T$.

\subsection{Triangle-triangle in 3-d space}\label{sec:intersectionsTriangleTriangle}
We are interested in detecting collisions between two triangles
$T_1=\triangle \ve{a_1}\ve{b_1}\ve{c_1}$ and $T_2=\triangle\ve{a_2}\ve{b_2}\ve{c_2}$ in 3-dimensional
space. First of all consider the coplanarity relation between the two
triangles, we have the cases:
\begin{enumerate}[label=\textbf{case \arabic*}]
\item\label[void]{en:itt:c} $T_1$ and $T_2$ are contained by the same plane;
\item\label[void]{en:itt:nc} $T_1$ and $T_2$ are contained by different planes.
\end{enumerate}
To simplify the problem we decided - analogously to the case of
intersection between segment and triangle - that when we are on \cref{en:itt:c}
we consider $T_1$ and $T_2$ not intersecting in any case, also if from a
geometrical point of view they share points. After this premise we can
assert that the possible relation between $T_1$ and $T_2$ can be
exclusively one
of the types \cite{schneider}:
\begin{enumerate}[label=\textbf{type \arabic*}, start=0]
\item\label[void]{en:itt:i0} $T_1$ and $T_2$ don't intersect;
\item\label[void]{en:itt:i1} two segments of $T_1$ intersect the plane
  section delimited by $T_2$, or vice versa;
\item\label[void]{en:itt:i2} one segment of $T_1$ intersect the plane
  section delimited by $T_2$ and one segment of $T_2$ intersect the
  plane section delimited by $T_1$.
\end{enumerate}

\begin{myfig}{Example of \cref{en:itt:i1} intersection between a triangle $T_1=\triangle \ve{a_1}\ve{b_1}\ve{c_1}$
    and another triangle $T_2=\triangle \ve{a_2}\ve{b_2}\ve{c_2}$.}{fig:trianglesIntersection1}
  \begin{tikzpicture}
    \coordinate (A1) at (0,0);
    \coordinate (B1) at (4,5);
    \coordinate (C1) at (8,1);

    \coordinate (cut1) at (barycentric cs:A1=0.8,B1=0.,C1=0.2);
    \coordinate (cut2) at (barycentric cs:A1=0.,B1=0.8,C1=0.2);

    \coordinate (A2) at (0,3);
    \coordinate (B2) at (2,5);    
    \coordinate (C2) at (4.5,1.5);

    \coordinate (Xs1) at (intersection of A1--B1 and C2--A2);
    \coordinate (Xs2) at (intersection of A1--B1 and C2--B2);
    \coordinate (X1) at (intersection of cut1--cut2 and C2--A2);
    \coordinate (X2) at (intersection of cut1--cut2 and C2--B2);

    \draw[poly] (Xs1) -- (A1) -- (C1) -- (B1) -- (Xs2);
    \draw[polyTract] (Xs1) -- (Xs2);
    \draw[poly] (X1) -- (A2) -- (B2) -- (X2);
    \draw[polyTract] (X1) -- (C2) -- (X2);
    \draw[cutting] (X1) -- (X2);

    \foreach \p in {A1,B1,C1,A2,B2,C2}
    \filldraw[vertex] (\p) circle (2pt);

    \filldraw[intersection] (X1) circle (2pt);
    \filldraw[intersection] (X2) circle (2pt);

    \node[below=0.5em] at (A1) {$\ve{a_1}$};
    \node[above=0.5em] at (B1) {$\ve{b_1}$};
    \node[below=0.5em] at (C1) {$\ve{c_1}$};
    \node[left=0.5em] at (A2) {$\ve{a_2}$};
    \node[above=0.5em] at (B2) {$\ve{b_2}$};
    \node[right=0.5em] at (C2) {$\ve{c_2}$};
    \node[below=0.2em] at (X1) {$\ve{x_1}$};
    \node[right=0.2em] at (X2) {$\ve{x_2}$};
  \end{tikzpicture}
\end{myfig}
\begin{myfig}{Example of \cref{en:itt:i2} intersection between a triangle $T_1=\triangle \ve{a_1}\ve{b_1}\ve{c_1}$
    and another triangle $T_2=\triangle \ve{a_2}\ve{b_2}\ve{c_2}$.}{fig:trianglesIntersection2}
  \begin{tikzpicture}
    \coordinate (A1) at (0,0);
    \coordinate (B1) at (4,5);
    \coordinate (C1) at (8,1);

    \coordinate (cut) at (barycentric cs:A1=0.8,B1=0.,C1=0.2);
    \coordinate (X2) at (barycentric cs:A1=0.,B1=0.8,C1=0.2);

    \coordinate (A2) at (0,6);
    \coordinate (B2) at (8,7);    
    \coordinate (C2) at (4.5,1.5);

    \coordinate (Xs1) at (intersection of A1--B1 and C2--A2);
    \coordinate (Xs2) at (intersection of C1--B1 and C2--B2);
    \coordinate (X1) at (intersection of cut--X2 and C2--A2);

    \draw[poly] (Xs1) -- (A1) -- (C1) -- (X2);
    \draw[polyTract] (Xs1) -- (B1) -- (X2);
    \draw[poly] (X1) -- (A2) -- (B2) -- (Xs2);
    \draw[polyTract] (X1) -- (C2) -- (Xs2);
    \draw[cutting] (X1) -- (X2);

    \foreach \p in {A1,B1,C1,A2,B2,C2}
    \filldraw[vertex] (\p) circle (2pt);

    \filldraw[intersection] (X1) circle (2pt);
    \filldraw[intersection] (X2) circle (2pt);

    \node[below=0.5em] at (A1) {$\ve{a_1}$};
    \node[above=0.5em] at (B1) {$\ve{b_1}$};
    \node[below=0.5em] at (C1) {$\ve{c_1}$};
    \node[left=0.5em] at (A2) {$\ve{a_2}$};
    \node[above=0.5em] at (B2) {$\ve{b_2}$};
    \node[right=0.5em] at (C2) {$\ve{c_2}$};
    \node[below=0.2em] at (X1) {$\ve{x_1}$};
    \node[right=0.2em] at (X2) {$\ve{x_2}$};
  \end{tikzpicture}
\end{myfig}
\begin{algo}{Find intersection between triangle $T_1$ and triangle $T_2$}{alg:intersectTriangles}
  \Function{intersect}{$T_1, T_2$}
  \ForAll{$S\in \{\overline{\ve{a_1}\ve{b_1}},\ \overline{\ve{b_1}\ve{c_1}},\ \overline{\ve{c_1}\ve{a_1}}\}$}
  \If{$intersect(S,T_2)$}\label{ln:intersectTriangles1}
  \State\Return $\True$
  \EndIf
  \EndFor
  \ForAll{$S\in \{\overline{\ve{a_2}\ve{b_2}},\ \overline{\ve{b_2}\ve{c_2}},\ \overline{\ve{c_2}\ve{a_2}}\}$}
  \If{$intersect(S,T_1)$}\label{ln:intersectTriangles2}
  \State\Return $\True$
  \EndIf
  \EndFor
  \State\Return $\False$
  \EndFunction
\end{algo}
On \cref{fig:trianglesIntersection1} and
\cref{fig:trianglesIntersection2} we can see two examples of
\cref{en:itt:i1} and \cref{en:itt:i2}. For finding if $T_1$ and $T_2$
intersects we need to check if every segment of $T_1$ intersect $T_2$
and every segment of $T_2$ intersect $T_1$. If we found at least one
segment that intersect with one triangle then $T_1$ and $T_2$
intersect. \Cref{alg:intersectTriangles} do exactly that, the function
$intersect$ on \cref{ln:intersectTriangles1} and
\cref{ln:intersectTriangles2} is the intersection between a segment
and a triangle described on \cref{alg:intersectSegmentTriangle}.

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../dissertation"
%%% End:
