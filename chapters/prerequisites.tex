\documentclass[dissertation.tex]{subfiles}
\begin{document}
\chapter{Prerequisites}
\section{Voronoi diagrams}\label{sec:voronoi}
\section{Splines and B-splines}\label{sec:spline}
A \emph{spline} is a piecewise polynomial function with prescribed
regularity on its domain.

More formally we define a spline
$$S:[a,b]\subset\mR\rightarrow\mR$$
as follows.
We have a partition of that interval defined by the \emph{breakpoints}
$$\tau = \{\tau_0,\dots,\tau_l\}$$
such that $a=\tau_0<\tau_1<\dots<\tau_{l-1}<\tau_l=b$ forming $l$
intervals
$$
I_i=
\begin{cases}
  [\tau_i,\tau_{i+1}) & \mbox{if } i=0,\dots,l-2\\
    [\tau_i,\tau_{i+1}] & \mbox{if } i=l-1\\
\end{cases}
$$
is possible to define the following spaces:
\paragraph{Piecewise polynomial functions space} $P_{m,\tau}$
is the space of the functions that are polynomials of maximum degree $m$
in each interval $I_i$ of the partition, formally:
\begin{multline*}
  P_{m,\tau}=\{f:[a,b]\rightarrow\mR\ \mid\ \exists p_0\dots
  p_{l-1}\in\Pi_m \ \text{such that}\\
  f(t)=p(t),\ \forall t\in I_i,\
  i=0\dots l-1\}
\end{multline*}
where $\Pi_m$ is the space of the polynomials of degree $\le m$. The
dimension of $P_{m,\tau}$ is $l(m+1)$ because the dimension of $\Pi_m$
is $m+1$.
\paragraph{Classic spline space} $S_{m,\tau}$ is the space of
the piecewise polynomial functions that have continuity $C^{m-1}$ in
the junctions of the intervals, formally:
$$
S_{m,\tau}=P_{m,\tau}\cap C^{m-1}[a,b].
$$
The dimension of this space is $l(m+1)-(l-1)\cdot m\,=\,l+m$.
\paragraph{Generalized spline space} $S_{m,\tau,M}$ is the
space of piecewise polynomial function of degree $m$ with a prescribed
regularity at each breakpoint ranging from $-1$ to $m-1$. The
regularity is prescribed by the multiplicity vector
$$
M=\{m_1,\dots,m_{l-1}\},\quad m_i\in\mN,\quad 1\leq m_i\leq m+1
$$
as follows,
\begin{multline*}
  S_{m,\tau,M}=\{f:[a,b]\rightarrow\mR\ \mid\ \exists p_0\dots
  p_{l-1}\in\Pi_m \ \text{such that}\\
  f(t)=p(t),\ \forall t\in I_i,\
  i=0\dots l-1\ \text{and}\\
  p_{i-1}^{(j)}(\tau_i)=p_{i}^{(j)}(\tau_i),\ j=0,\dots,m-m_i,\ i=1,\dots,l-1\}.
\end{multline*}
The dimension of the space is equal to 
$$
l(m+1)-\sum_{i=1}^{l-1}(m-m_i+1)=m+\mu +1\qquad(\mu=\sum_{i=1}^{l-1}m_i)
$$

and is true that
$$
\Pi_m\subseteq S_{m,\tau}\subseteq S_{m,\tau,M}\subseteq P_{m,\tau},
$$
in particular:
\begin{itemize}
  \item if $m_i=1$ for all $i=1,\dots,l-1$, then
    $S_{m,\tau,M}=S_{m,\tau}$;
  \item if $m_i=m+1$ for all $i=1,\dots,l-1$, then
    $S_{m,\tau,M}=P_{m,\tau}$.
\end{itemize}

\subsection{Truncated-powers base for classic splines}\label{sec:truncpow}
A truncated power $(t-\tau_i)_+^m$ is
defined by
$$
(t-\tau_i)_+^m=
\begin{cases}
  0,&\mbox{if}\quad t\leq\tau_i\\
  (t-\tau_i)^m, &\mbox{otherwise}.
\end{cases}
$$
Is possible to demonstrate that the functions
$$
g_i(t)=(t-\tau_i)_+^m)\ \in S_{m\tau},\quad i=1,\dots,l-1
$$
are linearly independents, and that
$$
1,t,t^2,\dots,t^m,(t-\tau_1)_+^m,\dots,(t-\tau_{l-1})_+^m
$$
form a base for the classic spline functions space. A generic element
from this space can be expressed like
\begin{equation}\label{eq:classicSplineElement}
  S(t)=\sum_{i=0}^m c_i t^i\, +\, \sum_{j=1}^{l-1} d_i (t-\tau_j)_+^m.
\end{equation}

\subsection{B-splines base for classic splines}\label{sec:bsplines}
\emph{B-splines} are a specific base wich can be alternatively used to
represent any generalized spline. In this
paragraph we consider only the classic splines $S_{m,\tau}$ and not
the generalized splines $S_{m,\tau,M}$, furthermore we consider the
\emph{order}: $k=m+1$.

For defining the B-splines we need to extend the partition vector
$\tau=\{\tau_0,\cdots,\tau_l\}$ with $m$ nodes to the left and $m$ to
the right, so we define a new vector
$$
T=\{t_0,\dots,t_{m-1},t_{m},\dots,t_{n+1},t_{n+2},\dots,t_{n+m+1}\}
$$
such that
$$
t_0\leq\dots\leq t_{m-1}\leq \{t_{m}\equiv\tau_0\equiv a\}<\dots<
\{t_{n+1}\equiv\tau_l\equiv b\}\leq t_{n+2}\leq\dots\leq t_{n+m+1}.
$$
$\tau$ have $l+1$ elements, so we can calculate the value of
$$
n=l+m-1,
$$
and the dimension of $S_{m,\tau}$ is
$$
l+m=n+1
$$
that is the number of necessary bases for the space.

The $n+1$ basis $N_{i,m+1}(t)$ of the B-splines of degree $m$ for
$i=0,\dots,n$ are defined by the 
recursive formula:
\begin{align*}
  N_{i,1}(t) &=
  \begin{cases}
    1,\quad \mbox{if}\quad t_i\leq t<t_{i+1}\\
    0,\quad \mbox{otherwise}
  \end{cases}\\
  N_{i,r}(t) &= \omega_{i,r-1}(t)\cdot N_{i,r-1}(t)\ +\
  (1-\omega_{i+1,r-1}(t))\cdot N_{i+1,r-1}(t)\\
             &\pushright r=2,\dots,m+1
\end{align*}
where
$$
\omega_{i,r}(t) = \begin{cases}
  \frac{t-t_i}{t_{i+r}-t_i},&\mbox{if }t_i\neq t_{i+r}\\
  0, &\mbox{otherwise.}
\end{cases}
$$

The elements of the classic splines space can be expressed in the form
\begin{equation}\label{eq:bsplineElement}
  S(t)=\sum_{i=0}^nv_i N_{i,k}(t).
\end{equation}

\subsection{Spline curves}
A parametric spline \emph{curve} $\ve{S}(t)$ is a curve in a certain
dimension $dim$ obtained applying a spline function to a set of points
in the same dimension $dim$
called \emph{control vertices}. We can apply the control vertices to a
spline expressed with the truncated powers as in
\cref{eq:classicSplineElement} replacing the coefficients $c_i$ and
$d_i$ with points
\begin{equation}\label{eq:classicSplineCurve}
  \ve{S}(t)=\sum_{i=0}^m \ve{c_i}\cdot t^i\, +\, \sum_{j=1}^{l-1} \ve{d_i}\cdot (t-\tau_j)_+^m  
\end{equation}

this form obtained with the truncated-powers base is not a practical
representation of a curve because
there isn't an intuitive correlation between the points
$\ve{c_i}$, $\ve{d_j}$ and the curve itself. Moreover
calculating $\ve{S}(t)$ is not a well conditioned problem.
 For resolving those problems we
defined the \emph{B-splines base} in \cref{sec:bsplines}.

We can apply control vertices to a spline expressed with the B-spline
base as in \cref{eq:bsplineElement} replacing the coefficients $v_i$
with points
\begin{equation}\label{eq:bsplineCurve}
  \ve{S}(t)=\sum_{i=0}^n\ve{v_i}\cdot N_{i,k}(t).
\end{equation}
The representation of \cref{eq:bsplineCurve} is more convenient
respect to the one of 
\cref{eq:classicSplineCurve} because the curve $\ve{S}(t)$ roughly
follow the shape given by the points $\ve{v_i}$. Those points are
called \emph{control vertices} and the polygon defined by them is
called \emph{control polygon} and they can be used to control the
shape of the curve.

\section{B-splines properties}\label{sec:bsplineProp}

\section{Lagrangian relaxation}\label{sec:lagrangianRelaxation}
A general constrained discrete optimization problem can be expressed in
the form:
\begin{equation}\label[problem]{eq:opt}
\begin{aligned}
& \underset{x}{\text{minimize}}
& & f(x) \\
& \text{subject to}
& & g(x)=0.
\end{aligned}
\end{equation}
Where $x$ is the state of the system in a discrete space $X$, $f(x)$
is the function to
minimize, and $g(x)=0$ is the constraint. the functions can also be
in a multidimensional discrete space, in that case the $x$ is a vector
$\ve{x}=(x_1,\dots,x_n)$ of variables.

For solving this class
of problem is necessary a \emph{Lagrange relaxation} method, that
augment the variable space $X$ by a \emph{Lagrange multiplier} space
$\Lambda$ of dimension equal to the number of constraints - one in the
\cref{eq:opt}.

The \emph{generalized discrete Lagrangian
  function} corresponding to the \cref{eq:opt} is:
\begin{equation}\label{eq:lagrangianFun}
  L_d(x,\lambda)=f(x)+\lambda H(g(x)).
\end{equation}
Where $\lambda$ is a variable in $\Lambda$, and if the dimension of
$\Lambda$ is more than one $\lambda$ must be transposed in
~\cref{eq:lagrangianFun}; $H(x)$ is a non negative function
with the property that $H(0)=0$, the purpose is to transform $g(x)$ in
a non negative function - if $g(x)$ isn't already not negative - for
instance can be $H(g(x))=|g(x)|$ or $H(g(x))=g^2(x)$.

Under the previous assumptions the set of \emph{local minima}
in \cref{eq:opt} - that respect the constraints -  coincide
with the set of \emph{discrete saddle point}
in the augmented space. A point $(x^*,\lambda^*)$ is a discrete saddle
point if:
\begin{equation*}
  L_d(x^*,\lambda)\leq L_d(x^*,\lambda^*)\leq L_d(x,\lambda^*)
\end{equation*}
for all $x\in\mathcal{N}(x^*)$ and for all $\lambda\in\Lambda$, where
$\mathcal{N}(x^*)$ is the set of all neighbours of $x^*$.

For resolving the optimization \cref{eq:opt} is necessary to
calculate all the discrete saddle points $(x^*,\lambda^*)$ using some
optimization method (i.e. simulated annealing) on the surface
represented by
\cref{eq:lagrangianFun}, and then choose
the one that minimize $f(x^*)$. $x^*$ is then the desired minimum.

\section{Simulated annealing}

\section{Intersections in space}\label{sec:intersections}
In the project we need to deal with three kind of collision detection
methods in 3-dimension euclidean space:
\begin{itemize}
\item we need to check if a point is inside or outside
  of a convex polyhedron;
\item we need to check if a segment intersect the
  surface of a triangle;
\item and we need to check if the surface of a
  triangle intersect the surface of another triangle.
\end{itemize}

\subsection{Point inside convex polyhedron in 3-d space}
For testing if a point $\ve{p}$ is inside a convex polyhedron $V$ with
vertices $\ve{v_1},\ve{v_2},\dots,\ve{v_n}$ we used a method that rely
on convex hulls \cite{deberg}\cite{schneider}.

\begin{algo}{Check if point $\ve{p}$ is inside convex polyhedron $V$}{alg:pointInPoly}
  \Function{isPointInPolyhedron}{$\ve{p}$, $V$}
  \State $inside\Ass\True$
  \State $C\Ass convexHull([\ve{p},\ve{v_1},\ve{v_2},\dots,\ve{v_n}])$
  \ForAll{$\ve{c}\in C$}\label{ln:pointInPolyFor}
  \If{$c=p$}
  \State $inside\Ass\False$
  \State \Break
  \EndIf
  \EndFor
  \State\Return $inside$
  \EndFunction
\end{algo}
As in the \cref{alg:pointInPoly} first we build the convex hull of all
the vertices of $V$ plus the point $\ve{p}$, then we check if $\ve{p}$
is on the convex hull or not. If $\ve{p}$ is on the convex hull that
means that $\ve{p}$ is external\footnote{Or $\ve{p}$ coincides with a
  vertex of $V$.} to $V$ because we have extended the convex hull
formed by the vertices of $V$. Otherwise this means that $\ve{p}$ is
inside $V$.

The cost of this algorithm is
\begin{equation*}
  \bigO(n\log n)
\end{equation*}
where $n$ is the number of vertices of $V$, because the cost for
constructing the convex hull is \cite{deberg} $\bigO(n\log n)$, and
then we have another negligible term $\bigO(n)$ for the cycle on \cref{ln:pointInPolyFor}.

\subsection{Segment-triangle in 3-d space}\label{sec:intersectionST}
We need to deal with the intersection between a segment
$S=\overline{\ve{a_2}\ve{b_2}}$ and a triangle
$T=\triangle\ve{a_1}\ve{b_1}\ve{c_1}$. $S$ and $T$ can be in one of
the cases:
\begin{enumerate}
\item\label[case]{en:ist:nc:ni} $S$ and $T$ don't intersect and the plane containing
  $T$ is not in the sheaf of planes generated by the line
  containing $S$;
\item\label[case]{en:ist:c:ni} $S$ and $T$ don't intersect and the plane containing
  $T$ is in the sheaf of planes generated by the line
  containing $S$;
\item\label[case]{en:ist:nc:i} $S$ and $T$ intersect in only one point and the plane containing
  $T$ is not in the sheaf of planes generated by the line
  containing $S$;
\item\label[case]{en:ist:c:i} $S$ and $T$ intersect in one or infinite points and the plane
  containing $T$ is in the sheaf of planes generated by the line
  containing $S$.
\end{enumerate}
The discriminant between the cases is that if $S$ and $T$ are
intersecting and if $S$ and $T$ are coplanar. The cases are resumed in
\cref{tab:intersectSegmentTriang}.
\begin{table}
  \centering
  \begin{tabular}{l|cc}
    &not coplanar&coplanar\\
    \hline
    not intersect& \cref{en:ist:nc:ni} & \cref{en:ist:c:ni}\\
    intersect& \cref{en:ist:nc:i} & \cref{en:ist:c:i}\\
  \end{tabular}
  \caption{Relations between $S$ and $T$}
  \label{tab:intersectSegmentTriang}
\end{table}

\begin{myfig}{Example intersection between a segment
    $\overline{\ve{a_2}\ve{b_2}}$ and a triangle $\triangle \ve{a_1}\ve{b_1}\ve{c_1}$.}{fig:segmentTriangleIntersection}
  \begin{tikzpicture}
    \coordinate (A1) at (0,0);
    \coordinate (B1) at (4,5);
    \coordinate (C1) at (8,1);

    \coordinate (cut1) at (barycentric cs:A1=0.8,B1=0.,C1=0.2);
    \coordinate (cut2) at (barycentric cs:A1=0.,B1=0.8,C1=0.2);

    \coordinate (A2) at (2,5);    
    \coordinate (B2) at (4.5,1.5);

    \coordinate (X) at (intersection of cut1--cut2 and B2--A2);

    \draw[poly] (A1) -- (C1) -- (B1) -- (A1);
    \draw[poly] (A2) -- (X);
    \draw[polyTract] (B2) -- (X);

    \foreach \p in {A1,B1,C1,A2,B2}
    \filldraw[vertex] (\p) circle (2pt);

    \filldraw[intersection] (X) circle (2pt);

    \node[below=0.5em] at (A1) {$\ve{a_1}$};
    \node[above=0.5em] at (B1) {$\ve{b_1}$};
    \node[below=0.5em] at (C1) {$\ve{c_1}$};
    \node[above=0.5em] at (A2) {$\ve{a_2}$};
    \node[right=0.5em] at (B2) {$\ve{b_2}$};
    \node[right=0.2em] at (X) {$\ve{x}$};
  \end{tikzpicture}
\end{myfig}
In \cref{fig:segmentTriangleIntersection} is visible a
\cref{en:ist:nc:i} relation where there is intersection in only one
point $\ve{x}$. For calculating if there is intersection we can solve
four equation in four unknowns \cite{schneider} where we look for
$\ve{x}$ searching a point that is a convex linear
combination of $\ve{a_2}$ and $\ve{b_2}$ and at the same time a convex
linear combination of $\ve{a_1}$,
$\ve{b_1}$ and $\ve{c_1}$. In other words when there is a collision,
then there is a solution for the unknowns
$\alpha$, $\beta$, $\gamma$, $\delta$, $\zeta$ of the system
\begin{equation}\label[system]{eq:segmentTriangleIntersection1}
  \begin{cases}
    \alpha \ve{a_2} + \beta\ve{b_2}=\gamma\ve{a_1}+\delta\ve{b_1}+\zeta\ve{c_1} \\
    \alpha + \beta = 1\\
    \gamma + \delta +\zeta=1
  \end{cases}
\end{equation}
with the further conditions
\begin{equation}\label[system]{eq:segmentTriangleIntersection1c}
  \begin{cases}
    \alpha \ge 0\\
    \beta \ge 0\\
    \gamma \ge 0\\
    \delta \ge 0\\
    \zeta \ge 0.
  \end{cases}
\end{equation}
Note that the first equation of
\cref{eq:segmentTriangleIntersection1} have vectorial coefficients
$\ve{a_2}$, $\ve{b_2}$, $\ve{a_1}$, $\ve{b_1}$, $\ve{c_1}$, so the
system is of five unknowns in five equations. If
\Cref{eq:segmentTriangleIntersection1} have one solution then we are
on \cref{en:ist:nc:ni} or \cref{en:ist:nc:i}, if have infinite
solution then we are on \cref{en:ist:c:ni} or \cref{en:ist:c:i}, if
don't have solution then $S$ or $T$ are degenerated. If
\cref{eq:segmentTriangleIntersection1c} is satisfied for the solution(s)
of \cref{eq:segmentTriangleIntersection1} then we are in
\cref{en:ist:nc:i} or \cref{en:ist:c:i}, if is not satisfied then we
are in \cref{en:ist:nc:ni} or \cref{en:ist:c:ni}.

We are interested in finding only \cref{en:ist:nc:i} collisions because for
simplicity we consider the special case of a segment that lay on the
surface of a triangle as not colliding with it, and for coherence we
restrict the conditions of \cref{eq:segmentTriangleIntersection1c} to
\begin{equation}
  \begin{cases}
    \alpha > 0\\
    \beta > 0\\
    \gamma > 0\\
    \delta > 0\\
    \zeta > 0.
  \end{cases}
\end{equation}

\Cref{eq:segmentTriangleIntersection1} can be simplified in the three
equations 
\begin{equation}\label[system]{eq:segmentTriangleIntersection2}
  \begin{cases}
    \alpha \ve{a_2} + (1-\alpha)\ve{b_2}=\beta\ve{a_1}+\gamma\ve{b_1}+(1-(\beta+\gamma))\ve{c_1} \\
  \end{cases}
\end{equation}
in the unknowns $\alpha$, $\beta$ and $\gamma$ with the relative conditions
\begin{equation}\label[system]{eq:segmentTriangleIntersection2c}
  \begin{cases}
    \alpha > 0\\
    \alpha < 1\\
    \beta > 0\\
    \gamma > 0\\
    \beta+\gamma<1.
  \end{cases}
\end{equation}

\begin{algo}{Find intersection between segment $S$ and triangle $T$}{alg:intersectSegmentTriangle}
  \Function{intersect}{$S, T$}
  \State $intersect\Ass\False$
  \State $coordinates\Ass\emptyset$
  \If{$(\alpha,\beta,\gamma)\Ass
    solve($\cref{eq:segmentTriangleIntersection2}$)$}\label{ln:intersectSegmentTriangleIf}
  \If{$satisfy($\cref{eq:segmentTriangleIntersection2c}$)$}
  \State $intersect\Ass\True$
  \State $coordinates\Ass(\beta, \gamma, 1-(\beta+\gamma))$
  \EndIf
  \EndIf
  \State\Return $(intersect, coordinates)$
  \EndFunction
\end{algo}
The \cref{alg:intersectSegmentTriangle} for calculating the
intersection consists basically on solve
\cref{eq:segmentTriangleIntersection2} with the parameters $\ve{a_2}$,
$\ve{b_2}$, $\ve{a_1}$, $\ve{b_1}$ and $\ve{c_1}$ from $S$ and $T$;
and then on checking if the solution is admissible. The condition of
\cref{ln:intersectSegmentTriangleIf} is $\True$ if
\cref{eq:segmentTriangleIntersection2} have solution and if that
is unique.

We have as a positive secondary effect that from the solution
$(\alpha,\beta,\gamma)$ of \cref{eq:segmentTriangleIntersection2} we
can extract the barycentric coordinates $(\beta, \gamma,
1-(\beta+\gamma))$ of the intersection point $\ve{x}$ on the system of
the vertices $\ve{a_1}$, $\ve{b_1}$, $\ve{c_1}$ of $T$.

\subsection{Triangle-triangle in 3-d space}\label{sec:intersectionsTriangleTriangle}

\begin{myfig}{Example of type 1 intersection between a triangle $\triangle \ve{a_1}\ve{b_1}\ve{c_1}$
    and another triangle $\triangle \ve{a_2}\ve{b_2}\ve{c_2}$.}{fig:trianglesIntersection1}
  \begin{tikzpicture}
    \coordinate (A1) at (0,0);
    \coordinate (B1) at (4,5);
    \coordinate (C1) at (8,1);

    \coordinate (cut1) at (barycentric cs:A1=0.8,B1=0.,C1=0.2);
    \coordinate (cut2) at (barycentric cs:A1=0.,B1=0.8,C1=0.2);

    \coordinate (A2) at (0,3);
    \coordinate (B2) at (2,5);    
    \coordinate (C2) at (4.5,1.5);

    \coordinate (Xs1) at (intersection of A1--B1 and C2--A2);
    \coordinate (Xs2) at (intersection of A1--B1 and C2--B2);
    \coordinate (X1) at (intersection of cut1--cut2 and C2--A2);
    \coordinate (X2) at (intersection of cut1--cut2 and C2--B2);

    \draw[poly] (Xs1) -- (A1) -- (C1) -- (B1) -- (Xs2);
    \draw[polyTract] (Xs1) -- (Xs2);
    \draw[poly] (X1) -- (A2) -- (B2) -- (X2);
    \draw[polyTract] (X1) -- (C2) -- (X2);
    \draw[cutting] (X1) -- (X2);

    \foreach \p in {A1,B1,C1,A2,B2,C2}
    \filldraw[vertex] (\p) circle (2pt);

    \filldraw[intersection] (X1) circle (2pt);
    \filldraw[intersection] (X2) circle (2pt);

    \node[below=0.5em] at (A1) {$\ve{a_1}$};
    \node[above=0.5em] at (B1) {$\ve{b_1}$};
    \node[below=0.5em] at (C1) {$\ve{c_1}$};
    \node[left=0.5em] at (A2) {$\ve{a_2}$};
    \node[above=0.5em] at (B2) {$\ve{b_2}$};
    \node[right=0.5em] at (C2) {$\ve{c_2}$};
    \node[below=0.2em] at (X1) {$\ve{x_1}$};
    \node[right=0.2em] at (X2) {$\ve{x_2}$};
  \end{tikzpicture}
\end{myfig}

\begin{myfig}{Example of type 2 intersection between a triangle $\triangle \ve{a_1}\ve{b_1}\ve{c_1}$
    and another triangle $\triangle \ve{a_2}\ve{b_2}\ve{c_2}$.}{fig:trianglesIntersection2}
  \begin{tikzpicture}
    \coordinate (A1) at (0,0);
    \coordinate (B1) at (4,5);
    \coordinate (C1) at (8,1);

    \coordinate (cut) at (barycentric cs:A1=0.8,B1=0.,C1=0.2);
    \coordinate (X2) at (barycentric cs:A1=0.,B1=0.8,C1=0.2);

    \coordinate (A2) at (0,6);
    \coordinate (B2) at (8,7);    
    \coordinate (C2) at (4.5,1.5);

    \coordinate (Xs1) at (intersection of A1--B1 and C2--A2);
    \coordinate (Xs2) at (intersection of C1--B1 and C2--B2);
    \coordinate (X1) at (intersection of cut--X2 and C2--A2);

    \draw[poly] (Xs1) -- (A1) -- (C1) -- (X2);
    \draw[polyTract] (Xs1) -- (B1) -- (X2);
    \draw[poly] (X1) -- (A2) -- (B2) -- (Xs2);
    \draw[polyTract] (X1) -- (C2) -- (Xs2);
    \draw[cutting] (X1) -- (X2);

    \foreach \p in {A1,B1,C1,A2,B2,C2}
    \filldraw[vertex] (\p) circle (2pt);

    \filldraw[intersection] (X1) circle (2pt);
    \filldraw[intersection] (X2) circle (2pt);

    \node[below=0.5em] at (A1) {$\ve{a_1}$};
    \node[above=0.5em] at (B1) {$\ve{b_1}$};
    \node[below=0.5em] at (C1) {$\ve{c_1}$};
    \node[left=0.5em] at (A2) {$\ve{a_2}$};
    \node[above=0.5em] at (B2) {$\ve{b_2}$};
    \node[right=0.5em] at (C2) {$\ve{c_2}$};
    \node[below=0.2em] at (X1) {$\ve{x_1}$};
    \node[right=0.2em] at (X2) {$\ve{x_2}$};
  \end{tikzpicture}
\end{myfig}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../dissertation"
%%% End:
