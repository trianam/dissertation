\documentclass[dissertation.tex]{subfiles}
\begin{document}
\chapter{Algorithms}\label{cha:algorithm}
In this chapter we analyze step-by-step the algorithms that implement
the different parts of the program. We do this with the help of the
test scene in \cref{fig:empty}.
\image{scrEmpty.png}{Initial scene.}{fig:empty}

The general idea is to use an open \bs curve of a certain degree
interpolating the chosen starting and ending points, whose
control polygon is a suitable modification of a polygonal chain
extracted from a graph
obtained with a \ac{VD} method. In \cref{sec:polChain} we
explain in detail how to
build such polygonal chain. Before using the chain as a control
polygon for the \bs, it is refined and adjusted - as explained in
detail in \cref{sec:obsAvoid} and \cref{sec:degreeInc} - in order to
ensure that the associated \bs curve has no obstacle
collision. Furthermore in \cref{sec:knotSel} w implemented a method
for an optional adaptive 
arrangement of the breakpoints of the \bs. Finally \cref{sec:postPro}
is devoted to an optional post processing of the path.

\section{Polygonal chain}\label{sec:polChain}\index{Polygonal chain}
In the first phase the objective is to extract a suitable polygonal chain from
the scene, such that the extremes coincide with the start point $\ve{s}$
and the end point $\ve{e}$. In particular we are interested in short length
chains. We calculate the shortest path
in a graph that is obtained by using an adaptation to three
dimensions of a well known bidimensional method
\cite{bhattacharya}\cite{ho-liu}\cite{seda-pich} that use
\acp{VD} as base.

We choose a Voronoi method because it builds a structure roughly
equidistant from obstacles, and so we have low probability of
collisions between the curve and the obstacles.

\subsection{Base Graph}\label{sec:baseGraph}\index{Graph}\index{$G$}
First we
start distributing points on the \acp{OTF} and on
an invisible bounding box, as in \cref{fig:sites}.
\imageDouble{scrSites-a.png}{scrSites-b.png}{Scene with Voronoi sites
  (distributed only on the
  obstacles surfaces on the left, and on obstacles and bounding box on
  the right).}{fig:sites}
The sites are distributed using a recursive method, for each triangle
of the scene we add three points - one for each
vertex, if not already added before - and then we calculate the area
of the triangle. If the area is bigger than a threshold we decompose
the triangle in four triangles adding three more vertices on the
midpoints of the edges of the original triangle as in
\cref{fig:triangleDec}, and repeating the process recursively for
each new triangle.
\begin{myfig}{Decomposition of an \ac{OTF}.}{fig:triangleDec}
  \begin{tikzpicture}[scale=2]
    \coordinate (a1) at (1,0);
    \coordinate (b1) at (2,1);
    \coordinate (c1) at (3,0.3);

    \path[obstacle] (a1) -- (b1) -- (c1) -- (a1);

    \coordinate (dist) at (3.5,0);
    \coordinate (a2) at ($ (a1) + (dist) $);
    \coordinate (b2) at ($ (b1) + (dist) $);
    \coordinate (c2) at ($ (c1) + (dist) $);

    \path[obstacle] (a2) -- (b2) -- (c2) -- (a2);
    \foreach \p in {a1,b1,c1,a2,b2,c2}
    \filldraw[site] (\p) circle (2pt); 

    \coordinate (ab) at ($ (a2)!0.5!(b2) $);
    \coordinate (bc) at ($ (b2)!0.5!(c2) $);
    \coordinate (ac) at ($ (a2)!0.5!(c2) $);

    \path[obstacleTract] (ab) -- (bc) -- (ac) -- (ab);

    \foreach \p in {ab,bc,ac}
    \filldraw[siteHigh] (\p) circle (2pt); 
  \end{tikzpicture}
\end{myfig}

We construct the \ac{VD} using the Fortune's algorithm
\cite{fortune} on
those points as input sites, and we build a graph
$$G=(V,E)$$
using the vertices
of the Voronoi cells as graph nodes in $V$, and the edges of the cells\footnote{Rejecting potential
  infinite edges.} as graph edges in $E$. Furthermore we make $G$
denser adding for every cell's face all the diagonals as edges (we
connect every vertex to every other vertex in a face).

After we prune such graph deleting every edge that
intersects an \ac{OTF} using the methods explained in
\cref{sec:intersections}. The edge-pruning process considers a margin
around the \acp{OTF} during the collision checks.
\image{scrGraph.png}{Scene with pruned graph.}{fig:graph}

The result, visible in \cref{fig:graph}, is a graph that embraces the
obstacles like a cobweb where the possible paths on it are roughly
equidistant from the obstacles.

\imageDouble{voronoi2d-a.eps}{voronoi2d-b.eps}{Voronoi graph in 2D
  before (left) and after (right) pruning.}{fig:voronoi2d}
As visible
in \cref{fig:voronoi2d},
in the bidimensional case the equivalent method implies distributing
the sites (the blue dots) in the edges of the polygonal obstacles and
then pruning the 
graph when an edge of the graph intersects an edge of the
obstacle. The result is a sparse graph composed of chains around the
obstacles (the green dots).

We decide to extend the method in 3 dimensions distributing points in
the whole \ac{OTF} surface, an alternative would be distributing
points only along the edges of the obstacles.

On the obtained graph $G$ we attach the desired start and end
points $\ve{s}$ and $\ve{e}$, and we can obtain a path between the two points using an
algorithm like Dijkstra \cite{dijkstra}\cite{knuth}. For attaching $\ve{s}$
and $\ve{e}$ we designed two
alternative methods:
\begin{itemize}
\item the first method finds the vertex $\ve{v_n}\in V_{vis}\subseteq V$ such
  that $dist(\ve{s},\ve{v_n})\leq dist(\ve{s},\ve{v_i})$, $\forall
  \ve{v_i}\in V_{vis}$, where
  \begin{equation*}
    V_{vis}=\{\ve{v}\in V\ :\ \overline{\ve{s} \ve{v_i}}\ \text{do not
      intersects any obstacle}\},
  \end{equation*}
  then adds $\ve{s}$ to $V$ and the edge $(\ve{s},\ve{v_n})$ to $E$;
  similarly for $\ve{e}$;
\item the second method adds $\ve{s}$ to $V$ and all the edges $(\ve{s},\ve{v_i})$
  $\forall \ve{v_i}\in V_{vis}$; similarly for $\ve{e}$.
\end{itemize}

Before using that path as a control polygon
we need to take into account the degree of the \bs and the
position of the obstacles, the details are in \cref{sec:obsAvoid} and
\cref{sec:degreeInc}.

\subsubsection{Complexity considerations}\index{Complexity!$G$ creation}\index{$G$!complexity}
Fortune's algorithm runs in time $\bigO(|\sitesSet|\log |\sitesSet|)$ \cite{deberg}
where $\sitesSet$ is
the set 
of input sites. If we impose a maximum area $A$ for the obstacles
\footnote{Inserting the obstacles in a progressive order, the area of the $i$-th
obstacle cannot be a function $f(i)$ of the number of
the obstacles} then $|\sitesSet|=\bigO(|\obsSet|)$ where $\obsSet$ is the set of
obstacles, because on the worst case we have that $|\sitesSet|=C\cdot A\cdot
|\obsSet|$ for
some constant $C$ that depends on the chosen density of sites per area.

In conclusion the time cost for the creation of the graph
is
\newcommand{\eqCostGraph}{\ensuremath{\bigO(|\obsSet|\log |\obsSet|)}}
\begin{equation}
  \label{eq:costGraph}
  \eqCostGraph
\end{equation}
and the number of the vertices in the graph
is 
\begin{equation}
  \label{eq:numV}
  |V|=\bigO(|\sitesSet|)=\bigO(|\obsSet|)
\end{equation}
because the number of vertices in the resulting graph is the
same order of number of input sites.

If we make the hypothesis of having maximum degree $k$ in $G$ -
i.e. each vertex in $V$ is connected at most to other $k$ vertices -
then we have that
\begin{equation}
  \label{eq:numE}
  |E|=\bigO(k|V|)=\bigO(k|\obsSet|).
\end{equation}
In the worst case $k=|V|$ and $|E|=\bigO(|V|^2)$ but for \acp{VD} in
plane there is a property that if we have $n$ input sites
that lay on a circumference, without any other site inside the
circumference, then the center of the circumference is a vertex shared
by $n$ cells (\cref{sec:voronoi} for details). The same property hold
in the 3D case with respect to spheres. We can make the assumption that no more than three sites can lay
on a circumference so no vertex can have more than three neighbours,
or the same with four vertices in sphere, and this assumption is
plausible because we use floating point numbers for the coordinates of
the vertices of the obstacles, and it is unlikely that more than
four points lay on a sphere. With this assumption $k$ is a constant,
and \cref{eq:numE} become
\begin{equation*}
  |E|=\bigO(|V|)=\bigO(|\obsSet|).
\end{equation*}

For pruning the graph of every edge that intersects obstacles we need
to solve a system of three unknowns in thre equations for every edge
and every \ac{OTF}\footnote{See \cref{sec:intersectionST}.}, so
we have a cost of
\newcommand{\eqCostPruning}{\ensuremath{\bigO(k|\obsSet|^2)}}
\begin{equation}
  \label{eq:costPruning}
  \bigO(|E|\cdot|\obsSet|)=\eqCostPruning
\end{equation}
and if we make the assumption of $k$ constant
\begin{equation*}
  \bigO(|\obsSet|^2)
\end{equation*}

\subsection{Graph's transformation}\label{sec:trigraph}\index{Graph!triple's graph}\index{$G_t$}
Before calculating the shortest path on the chosen graph with Dijkstra
\cite{dijkstra}\cite{knuth}, we
transform it in a graph containing all the triples
of three adjacent vertices in the original graph. This because we want
to filter the triples for collisions as described in
\cref{sec:inter1}. We call the transformed graph
$$G_t=(V_t,E_t)$$
where we have triples of vertices of $G$ in $V_t$.

The original graph $G$ is not directed and it is weighted
with the distance from vertex to vertex. The transformed graph $G_t$ is
directed and weighted, where if in $G$ the nodes $\ve{a}$
and $\ve{b}$ are
neighbouring, and $\ve{b}$ and $\ve{c}$ are neighbouring, then $G_t$
has the two nodes $(\ve{a},\ve{b},\ve{c})$ and $(\ve{c},\ve{b},\ve{a})$. In
$G_t$ a node $(\ve{a_1},\ve{b_1},\ve{c_1})$ is a predecessor of
$(\ve{a_2},\ve{b_2},\ve{c_2})$ if $\ve{b_1}=\ve{a_2}$ and $\ve{c_1}=\ve{b_2}$, and the weight of the arc
from $(\ve{a_1},\ve{b_1},\ve{c_1})$ to $(\ve{a_2},\ve{b_2},\ve{c_2})$ in $G_t$ is
equal to
the weight of the arc from $\ve{a_1}$ to $\ve{b_1}(=\ve{a_2})$ in $G$.

\begin{algo}{Create triples graph $G_t$}{alg:createTripleGraph}
  \Function{createTriplesGraph}{$G$}
  \State $V_t\Ass E_t\Ass \emptyset$
  \ForAll{$(\ve{a},\ve{b})\in E$}\label{ln:tripleFor0}
  \State $leftOut\Ass leftIn\Ass rightOut\Ass rightIn\Ass \emptyset$
  \ForAll{$\ve{v}\in N_G(\ve{a})\setminus\{\ve{b}\}$}
  \State $leftOut \Ass leftOut\cup \{(\ve{v},\ve{a},\ve{b})\}$
  \State $leftIn \Ass leftIn\cup \{(\ve{b},\ve{a},\ve{v})\}$
  \State $V_t \Ass V_t\cup \{(\ve{v},\ve{a},\ve{b}), (\ve{b},\ve{a},\ve{v})\}$
  \EndFor
  \ForAll{$\ve{v}\in N_G(\ve{b})\setminus\{\ve{a}\}$}
  \State $rightOut \Ass rightOut\cup \{(\ve{v},\ve{b},\ve{a})\}$
  \State $rightIn \Ass rightIn\cup \{(\ve{a},\ve{b},\ve{v})\}$
  \State $V_t \Ass V_t\cup \{(\ve{v},\ve{b},\ve{a}), (\ve{a},\ve{b},\ve{v})\}$
  \EndFor
  \ForAll{$\ve{o}\in leftOut$}
  \ForAll{$\ve{i}\in rightIn$}
  \State $E_t \Ass E_t\cup (\ve{o},\ve{i})$
  \EndFor
  \EndFor
  \ForAll{$\ve{o}\in rightOut$}\label{ln:tripleFor1}
  \ForAll{$\ve{i}\in leftIn$}\label{ln:tripleFor2}
  \State $E_t \Ass E_t\cup (\ve{o},\ve{i})$
  \EndFor
  \EndFor
  \EndFor
  \State $G_t\Ass(V_t,E_t)$
  \State\Return $G_t$
  \EndFunction
\end{algo}
The steps necessary for creating $G_t$ are summarized in
\cref{alg:createTripleGraph}. The input $G$ is the base graph
which has vertices $V$ and edges $E$, $N_G(\ve{a})$ is the set of
neighbours in $G$ of the vertex $\ve{a}$, and the output is $G_t$.

The transformation of the graph is useful only for the obstacle
avoidance algorithm of
\cref{sec:inter1}, theoretically is possible to bypass such
transformation for the algorithm described in \cref{sec:inter2}.

\subsubsection{Complexity considerations}\index{Complexity!$G_t$ creation}\index{$G_t$!complexity}
If we suppose a maximum degree $k$ for each vertex in the graph $G$ -
i.e. each vertex in $V$ can have at most $k$ edges insisting on
it, then the number of vertices in the transformed graph $G_t$ is 
\begin{equation}
  \label{eq:numTriples}
  |V_t|\leq |V|\cdot k\cdot(k-1)=\bigO(k^2|V|)
\end{equation}
because for each vertex $\ve{v}$ in $G$ we need to
consider all the neighbours of $\ve{v}$ and the neighbours of the neighbours
of $\ve{v}$ (excluded $\ve{v}$).

For how we defined the triples neighbour rule in $G_t$ we have
that each triple is a predecessor of at most $k-1$ other triples. For
instance $(\ve{a},\ve{b},\ve{c})$ in $V_t$ is the predecessor of all the triples
$(\ve{b},\ve{c},*)$ where $*$ can be one of the $k$ neighbours
of $\ve{c}$ in $V$ excluded $\ve{b}$. So the number of edges in $G_t$ is
\begin{equation}
  \label{eq:numEdgesTriples}
  |E_t|\leq |V_t|\cdot (k-1)=\bigO(k|V_t|)=\bigO(k^3|V|)
\end{equation}

Also the time cost for the creation of $G_t$ is
\newcommand{\eqCostVt}{\ensuremath{\bigO(k^3|\obsSet|)}}
\begin{equation}
  \label{eq:costVt}
  \bigO(k^2|E|)=\eqCostVt
\end{equation}
because \cref{alg:createTripleGraph} for creating the transformed
graph scans all the edges $e$ on \cref{ln:tripleFor0} and for each
iteration
the biggest cost is due to the two \emph{for} on \cref{ln:tripleFor1} and
\cref{ln:tripleFor2}. Each one scans triples created from at most
$k$ neighbours
of the vertices at the extremes of $e$.

\section{Obstacle avoidance}\label{sec:obsAvoid}
Before using the polynomial chain extracted as
explained in \cref{sec:polChain} as a control polygon for the
\bs, we need to deal with a
problem: every possible path in the graph $G$ is
free from collisions by construction - in fact we prune the graph of
every edge that intersects an obstacle - but this does not guarantee
that the associated curve will not cross any obstacle. This concept is
exemplified in
\cref{fig:intersect}.
\begin{myfig}{\bs that intersects an obstacle in the plane.}{fig:intersect}
  \begin{tikzpicture}
    \path[obstacle] (1,0) -- (2,1) -- (3,0) -- (1,0);
    \draw[controlPoly] (0,0) -- (2,2) -- (4,0);
    \draw[spline] (0,0) to [bend left=40] (4,0);

    \filldraw[controlVert] (0,0) circle (2pt);
    \filldraw[controlVert] (2,2) circle (2pt);
    \filldraw[controlVert] (4,0) circle (2pt);
  \end{tikzpicture}
\end{myfig}

In this chapter we make the hypothesis of using
quadratic \bss\footnote{\bss curves with degree 2 or equivalently order 3.}, in
\cref{sec:degreeInc} it is explained how is possible to use curves with
higher degree. With this assumption we can exploit the \acp{CHP}
explained in \cref{sec:bsplineProp}, and assert that the 
resulting curve is contained inside the union of all the triangles of
three consecutive control vertices of the control
polygon. Using that property we can resolve the problem of the
collision, maintaining free 
from collision with \acp{OTF} all the triangles associated with the control
polygon. Note that the \ac{CHP} of quadratic
\bss is valid also in space, so the convex hull is still composed
of triangles, like the faces of the
obstacles. This simplifies all the checks for collisions because they
are all between triangles in space and we can use the methods
described in \cref{sec:intersections}.

We designed two different algorithms for dealing with the collision
problem. The first solution described in \cref{sec:inter1} implements
a modified version of Dijkstra's
algorithm that finds the shortest path from start to end in the graph
such that all the triangles formed by three consecutive points in such path
are free from collisions. The second solution described in
\cref{sec:inter2} use the classical Dijkstra's algorithm to find
the shortest path from $s$ to $e$ in the graph $G$, checking later for
collisions in the triangles formed of three consecutive points in such
path. When a collision is found we add vertices to the path for dealing
with that.

\subsection{First solution: Dijkstra's algorithm in $G_t$}\label{sec:inter1}\index{Dijkstra}\index{Dijkstra in $G_t$}
The first solution of the problem exploits the graph $G_t$ obtained as
explained in \cref{sec:trigraph}. Before applying Dijkstra's algorithm
to $G_t$ all the triples are filtered checking if the
triangle composed of the vertices of the triple intersect an
\ac{OTF}. If a triple intersect an obstacle then it is removed from the
graph
and so a path cannot pass from such vertices in that order.

Note that if a triple $(\ve{a},\ve{b},\ve{c})$ is removed from $V_t$ - and
consequently also the triple $(\ve{c},\ve{b},\ve{a})$ - not
necessarily this excludes
the three vertices $\ve{a}$, $\ve{b}$, $\ve{c}$ from being part of the final
polynomial chain. For instance in
\cref{fig:exampleTriples} we have a graph $G$ with vertices
$\ve{a},\ve{b},\ve{c},\ve{d},\ve{e},\ve{f}$ and an obstacles that
intersects triples on the transformed graph\footnote{In the plane, this graph cannot be
  obtained using the procedure based on \acp{VD} explained in
  \cref{sec:voronoi}, but a similar situation is plausible
  considering Voronoi cells in space.} $G_t$. The triple
$(\ve{a},\ve{b},\ve{c})$ and $(\ve{c},\ve{b},\ve{a})$ will be removed from $G_t$ because
the corresponding triangle intersects the obstacle, and the path
$\ve{d}\rightarrow \ve{a}\rightarrow \ve{b}\rightarrow \ve{c}\rightarrow \ve{e}$ cannot be
admissible. This doesn't preclude the nodes $\ve{a}$, $\ve{b}$ and $\ve{c}$ to be part
of the final admissible path $\ve{d}\rightarrow \ve{a}\rightarrow \ve{b}\rightarrow \ve{e}\rightarrow \ve{c}\rightarrow \ve{f}$.
\begin{myfig}{Example of triples.}{fig:exampleTriples}
  \begin{tikzpicture}
    \coordinate (D) at (-1,1);
    \coordinate (A) at (0,0);
    \coordinate (B) at (2,2);
    \coordinate (C) at (4,0);
    \coordinate (E) at (3,2);
    \coordinate (F) at (5,1);
    \path[obstacle] (1,-0.5) -- (2,1) -- (3,-0.5) -- (1,-0.5);
    \draw[controlPoly] (D) -- (A) -- (B) -- (C) -- (F);
    \draw[controlPoly] (B) -- (E) -- (C);

    \filldraw[controlVert] (D) circle (2pt);
    \filldraw[controlVert] (A) circle (2pt);
    \filldraw[controlVert] (B) circle (2pt);
    \filldraw[controlVert] (C) circle (2pt);
    \filldraw[controlVert] (E) circle (2pt);
    \filldraw[controlVert] (F) circle (2pt);

    \node[above=0.5em] at (D) {$\ve{d}$};
    \node[below=0.5em] at (A) {$\ve{a}$};
    \node[above=0.5em] at (B) {$\ve{b}$};
    \node[below=0.5em] at (C) {$\ve{c}$};
    \node[above=0.5em] at (E) {$\ve{e}$};
    \node[above=0.5em] at (F) {$\ve{f}$};
  \end{tikzpicture}
\end{myfig}

On the cleaned transformed graph it is possible to find the shortest
path on the triples
$$
P_t=(\ve{a_0},\ve{b_0},\ve{c_0}), (\ve{a_1},\ve{b_1},\ve{c_1}),\dots,(\ve{a_i},\ve{b_i},\ve{c_i}),\dots,(\ve{a_n},\ve{b_n},\ve{c_n})
$$
 using
an algorithm like Dijkstra. Then the shortest
path $P$ in $G$ is constructed by taking the central vertex $\ve{b_i}$
of every 
triple $(\ve{a_i},\ve{b_i},\ve{c_i})$ of $P_t$, plus the extremes $\ve{a_0}$ and $\ve{c_n}$
of the first and last triples, obtaining
$$
P=\ve{a_0},\ve{b_0},\ve{b_1},\dots,\ve{b_i},\dots,\ve{b_{n-1}},\ve{b_n},\ve{c_n}.
$$

\imageDouble{scrSolution1a.png}{scrSolution1b.png}{Effects of
  application of solution one.}{fig:sol11}[
\node[imageLabel] at (0.7,0.62) {$\ve{a_1}$};
\node[imageLabel] (B) at (0.35,0.4) {$\ve{b_1}$};
\node[imageLabel] (C) at (0.2,0.4) {$\ve{c_1}$};
\node[imageLabel] (O) at (0.8,0.2) {$Obs$};
\path[imageArrow] (B) -- (0.36,0.555);
\path[imageArrow] (C) -- (0.3,0.585);
\path[imageArrow] (O) -- (0.6,0.3);
][
\node[imageLabel] (A) at (0.7,0.7) {$\ve{a_2}$};
\node[imageLabel] (B) at (0.5,0.4) {$\ve{b_2}$};
\node[imageLabel] (C) at (0.35,0.4) {$\ve{c_2}$};
\node[imageLabel] (D) at (0.2,0.4) {$\ve{d_2}$};
\node[imageLabel] (O) at (0.8,0.2) {$Obs$};
\path[imageArrow] (A) -- (0.58,0.61);
\path[imageArrow] (B) -- (0.44,0.52);
\path[imageArrow] (C) -- (0.36,0.555);
\path[imageArrow] (D) -- (0.3,0.585);
\path[imageArrow] (O) -- (0.6,0.3);
]
\imageDouble{scrSolution1a2.png}{scrSolution1b2.png}{Effects of
  application of solution one, other view point.}{fig:sol12}[
\node[imageLabel] at (0.2,0.1) {$\ve{a_1}$};
\node[imageLabel] at (0.45,0.6) {$\ve{b_1}$};
\node[imageLabel] at (0.65,0.85) {$\ve{c_1}$};
\node[imageLabel] at (0.8,0.2) {$Obs$};
][
\node[imageLabel] at (0.15,0.2) {$\ve{a_2}$};
\node[imageLabel] at (0.3,0.4) {$\ve{b_2}$};
\node[imageLabel] at (0.45,0.6) {$\ve{c_2}$};
\node[imageLabel] at (0.65,0.85) {$\ve{d_2}$};
\node[imageLabel] at (0.8,0.2) {$Obs$};
]
In \cref{fig:sol11} and \cref{fig:sol12} the effect of the
application of the first solution is shown. The triangle formed by the
vertices $\ve{a_1}$, $\ve{b_1}$, $\ve{c_1}$ on the left picture of \cref{fig:sol11}
is colliding with the obstacle $Obs$ in the back. On the right picture
there
is the path $\ve{a_2},\ve{b_2},\ve{c_2},\ve{d_2}$ obtained applying the solution, where no
triangles in the
path collide with obstacles. In \cref{fig:sol12} another
point of view of pictures shown in \cref{fig:sol11} is visible.

\subsubsection{Complexity considerations}\index{Complexity!Dijkstra's algorithm in $G_t$}\index{Dijkstra in $G_t$!complexity}
For each triple and each \ac{OTF} we need to solve three $3\times 3$
linear systems for the
collision check\footnote{See
  \cref{sec:intersectionsTriangleTriangle}.}, so in total
the cost is
\begin{equation*}
  \bigO(|V_t|\cdot |\obsSet|)
\end{equation*}
and for \cref{eq:numV} and \cref{eq:numTriples} this is equal to
\newcommand{\eqCostColl}{\ensuremath{\bigO(|\obsSet|^2 k^2)}}
\begin{equation}
  \label{eq:costColl}
  \eqCostColl .
\end{equation}

The cost of applying Dijkstra's algorithm\footnote{In the worst case
  where no triples are removed in the cleaning phase.} in $G_t$ is \cite{bondy}\cite{lavalle}
\newcommand{\eqCostDijkstraTriples}{\ensuremath{\bigO(k^3|\obsSet|+k^2|\obsSet|\log(k^2|\obsSet|)}}
\begin{equation}
  \label{eq:costDijkstraTriples}
  \begin{split}
    \bigO(|E_t|+|V_t|\log |V_t|) &= \bigO(k^3|V|+k^2|V|\log(k^2|V|)\\
    &= \eqCostDijkstraTriples.
  \end{split}
\end{equation}
Such cost has two special cases:
\begin{itemize}
\item if $G$ is a \emph{clique} - i.e. each
  node in $V$ is connected to every other node \cite{bondy} - then
  $k=|V|-1$ and the cost is
  \begin{equation*}
    \bigO(|V|^4);
  \end{equation*}
\item if $k$ is constant - i.e. doesn't grow with $|V|$ - the
  cost is
  \begin{equation*}
    \bigO(|V|\log|V|).
  \end{equation*}
\end{itemize}
The latter case is the more plausible if we assume the hypothesis that
no more than four input sites in space can be on the
same sphere, in fact in that case
every Voronoi cell cannot have a vertex with more than four edges
connected to it (see \cref{sec:voronoi} for details).

If we sum all the costs we obtain:
\newcommand{\eqCostTotalOne}{\ensuremath{\bigO(k^2|\obsSet|^2+k^3|\obsSet|)}}
\begin{equation}\label{eq:costTotalOne}
  \eqCostTotalOne
\end{equation}
where all the other terms are absorbed in those two. If we have $k$
constant as we said before then we have an overall cost of
\newcommand{\eqCostTotalOneK}{\ensuremath{\bigO(|\obsSet|^2)}}
\begin{equation}\label{eq:costTotalOneK}
  \eqCostTotalOneK
\end{equation}
that derives from the collision-check controls.

We can improve
this result if we divide the algorithm in two parts:
\begin{enumerate}
\item first we 
  can construct the graph once with cost $\bigO(|\obsSet|^2)$;
\item then we can
  use the graph in different situations\footnote{With specific starting
    and ending points} with cost $\bigO(|\obsSet|\log |\obsSet|)$, only for the
  routing.
\end{enumerate}

\begin{table}
  \centering
  \begin{tabular}{|l|c|r|}
    \hline
    Description&Cost&Reference\\
    \hline
    \hline
    Creation of $G$&\eqCostGraph&\cref{eq:costGraph}\\
    Pruning of $G$&\eqCostPruning&\cref{eq:costPruning}\\
    Creation of $G_t$&\eqCostVt&\cref{eq:costVt}\\
    Pruning of $G_t$&\eqCostColl&\cref{eq:costColl}\\
    Routing in $G_t$& \eqCostDijkstraTriples&\cref{eq:costDijkstraTriples}\\
    \hline
    Total&\eqCostTotalOne&\cref{eq:costTotalOne}\\
    Total ($k$ constant)&\eqCostTotalOneK&\cref{eq:costTotalOneK}\\
    \hline
  \end{tabular}
  \caption{Summary of the costs for solution one}
  \label{tab:costsSol1}
\end{table}
On \cref{tab:costsSol1} we resume all the terms that contributes to
the total costs, and the total cost itself.

\subsection{Second solution: Dijkstra's algorithm in $G$}\label{sec:inter2}\index{Dijkstra}\index{Dijkstra in $G$}
The First solution is interesting from an algorithmic point of view,
but it is not very practical. It ignores all the triples that
intersect an obstacle, thus possible paths in $G$ are lost. 

We managed to develop a
solution that uses another approach: obtain the shortest path 
from the Voronoi's graph $G$ directly using Dijkstra's algorithm,
without removing any triple. On that path
- that we call $P$ - we
check every triple of consecutive vertices, and if it collides with an
\ac{OTF} then we take countermeasures (see
\cref{sec:intersectionsTriangleTriangle} for the procedure implemented
to identify collisions between two triangles). For instance if the path
is composed from the vertices:
\begin{equation*}
  P=(\ve{v_0},\ve{v_1},\dots,\ve{v_n})
\end{equation*}
then we check every one of the triangles 
\begin{eqnarray*}
T_0 &=& \triangle \ve{v_0}\ve{v_1}\ve{v_2}\\
T_1 &=& \triangle \ve{v_1}\ve{v_2}\ve{v_3}\\
&\cdots&\\
T_i &=& \triangle \ve{v_i}\ve{v_{i+1}}\ve{v_{i+2}}\\
&\cdots&\\
T_{n-3} &=& \triangle \ve{v_{n-3}}\ve{v_{n-2}}\ve{v_{n-1}}\\
T_{n-2} &=& \triangle \ve{v_{n-2}}\ve{v_{n-1}}\ve{v_n}
\end{eqnarray*}
for intersections with \acp{OTF}, where $\triangle \ve{v_i}\ve{v_j}\ve{v_k}$ denotes the
triangle with
vertices the points $\ve{v_i}$, $\ve{v_j}$ and $\ve{v_k}$.
 
Consider also that $G$ is pruned from all the edges that intersect any
obstacle, so none of the edges of the triangles $T_i$ can intersect
an \ac{OTF}. The only possibility is that edges\footnote{At most two
  edges for each \ac{OTF} if we ignore special 
  cases.} of \ac{OTF} intersect a
triangle $T_i$. So for each $T_i$ we have a (possibly empty) set of points
of intersection between it and the edges of each \ac{OTF} - we call
that set $O$.
\begin{myfig}{$T_i$($=\triangle \ve{v_i}\ve{v_{i+1}}\ve{v_{i+2}}$) and the points
    $\ve{o_1},\ve{o_2},\ve{o_3}$ of intersection between it and the edges of some \acp{OTF}.}{fig:triangleIntersection}
  \begin{tikzpicture}
    \coordinate (P) at (-1,0);
    \coordinate (A) at (0,0);
    \coordinate (B) at (4,5);
    \coordinate (C) at (8,1);
    \coordinate (D) at (9,1);
    \coordinate (O1) at (barycentric cs:A=0.2,B=0.6,C=0.2);
    \coordinate (O2) at (barycentric cs:A=0.5,B=0.3,C=0.2);
    \coordinate (O3) at (barycentric cs:A=0.3,B=0.2,C=0.5);
    \coordinate (W1) at (barycentric cs:A=0.4,B=0.6,C=0.);
    \coordinate (W2) at (barycentric cs:A=0.,B=0.6,C=0.4);

    \draw[controlPoly] (A) -- (B) -- (C);
    \draw[controlPolyTract] (P) -- (A);
    \draw[controlPolyTract] (C) -- (D);
    \draw[controlPolyTractHigh] (W1) -- (W2);
    \draw[controlPolyTractHigh] (A) -- (C);

    \filldraw[controlVert] (A) circle (2pt);
    \filldraw[controlVert] (B) circle (2pt);
    \filldraw[controlVert] (C) circle (2pt);
    \filldraw[obstaclePoint] (O1) circle (2pt);
    \filldraw[obstaclePoint] (O2) circle (2pt);
    \filldraw[obstaclePoint] (O3) circle (2pt);
    \filldraw[controlVertHigh] (W1) circle (2pt);
    \filldraw[controlVertHigh] (W2) circle (2pt);

    \node[below=0.5em] at (A) {$\ve{v_i}$};
    \node[above=0.5em] at (B) {$\ve{v_{i+1}}$};
    \node[below=0.5em] at (C) {$\ve{v_{i+2}}$};
    \node[below right=0.2em] (O1n) at (O1) {$\ve{o_1}$};
    \node[below=0.2em] at (O1n) {$\scriptstyle(\equiv \ve{o_{near}})$};
    \node[left=0.2em] at (O2) {$\ve{o_2}$};
    \node[below=0.2em] at (O3) {$\ve{o_3}$};
    \node[left=0.5em] at (W1) {$\ve{w_1}$};
    \node[right=0.5em] at (W2) {$\ve{w_2}$};
  \end{tikzpicture}
\end{myfig}

In \cref{fig:triangleIntersection} we have an example of the triangle
\begin{equation*}
  T_i = \triangle \ve{v_i}\ve{v_{i+1}}\ve{v_{i+2}} 
\end{equation*}
that is
intersected by obstacles in the points
\begin{equation*}
  O = \{\ve{o_1},\ve{o_2},\ve{o_3}\}.
\end{equation*}
where each one of the points in $O$ is expressed in barycentric
coordinates of the vertices $\ve{v_i}$, $\ve{v_{i+1}}$ and $\ve{v_{i+2}}$ of the
triangle:
\begin{eqnarray*}
  \ve{o_1}&=&\alpha_1 \ve{v_i}+\beta_1 \ve{v_{i+1}}+\gamma_1 \ve{v_{i+2}}\\
  \ve{o_2}&=&\alpha_2 \ve{v_i}+\beta_2 \ve{v_{i+1}}+\gamma_2 \ve{v_{i+2}}\\
  \ve{o_3}&=&\alpha_3 \ve{v_i}+\beta_3 \ve{v_{i+1}}+\gamma_3 \ve{v_{i+2}}
\end{eqnarray*}
where $\alpha_i+\beta_i+\gamma_i=1$ for $i=1,2,3$.

We want to avoid collisions adding vertices in the control
polygon, such that consecutive triangles are free from obstacles. We
obtain this by adding two new control vertices: 
\begin{itemize}
\item $\ve{w_1}$ between $\ve{v_i}$ and $\ve{v_{i+1}}$;
\item $\ve{w_2}$ between $\ve{v_{i+1}}$ and $\ve{v_{i+2}}$.
\end{itemize}
We add those
points in a manner such that the segment $\overline{\ve{w_1}\ve{w_2}}$ is
parallel to the segment $\overline{\ve{v_i}\ve{v_{i+2}}}$ and such that
$\overline{\ve{w_1}\ve{w_2}}$ passes just above the obstacle point
$\ve{o_{near}}$ that is the nearest
to $\ve{v_{i+1}}$ ($\ve{o_1}$ in
\cref{fig:triangleIntersection}). The degenerate triangles $\triangle \ve{v_i}\ve{w_1}\ve{v_{i+1}}$ and $\triangle
\ve{v_{i+1}}\ve{w_2}\ve{v_{i+2}}$, and the not degenerate triangle
$\triangle \ve{w_1}\ve{v_{i+1}}\ve{w_2}$ replace the original triangle
$T_i$ and they do not collide with obstacles for construction.

When we check for collisions between a segment and a triangle we
resolve a system of three unknowns in
three equations and from the solutions we extract the barycentric
coordinates of
the point of collision. When we have all the coordinates of the points
in $O$ we can obtain $\ve{o_{near}}$ picking the one with the biggest $\beta$
and then, using the corresponding $\beta_{near}$, we can obtain
\begin{eqnarray*}
  W_1&=&\beta_{near} \ve{v_{i+1}}+(1-\beta_{near})\ve{v_i}\\
  W_2&=&\beta_{near} \ve{v_{i+1}}+(1-\beta_{near})\ve{v_{i+2}}.
\end{eqnarray*}

\imageDouble{scrSolution2a.png}{scrSolution2b.png}{Effects of application of solution two.}{fig:sol21}[
\node[imageLabel] at (0.7,0.62) {$\ve{v_i}$};
\node[imageLabel] (B) at (0.45,0.4) {$\ve{v_{i+1}}$};
\node[imageLabel] (C) at (0.2,0.4) {$\ve{v_{i+2}}$};
\node[imageLabel] (O) at (0.8,0.2) {$Obs$};
\path[imageArrow] (B) -- (0.36,0.555);
\path[imageArrow] (C) -- (0.3,0.585);
\path[imageArrow] (O) -- (0.6,0.3);
][
\node[imageLabel] (W1) at (0.75,0.7) {$\ve{w_1}$};
\node[imageLabel] (W2) at (0.2,0.4) {$\ve{w_2}$};
\node[imageLabel] (O) at (0.8,0.2) {$Obs$};
\path[imageArrow] (W1) -- (0.61,0.6);
\path[imageArrow] (W2) -- (0.31,0.58);
\path[imageArrow] (O) -- (0.6,0.3);
]
\imageDouble{scrSolution2a2.png}{scrSolution2b2.png}{Effects of
  application of solution two, other view point.}{fig:sol22}[
\node[imageLabel] at (0.2,0.1) {$\ve{v_i}$};
\node[imageLabel] at (0.43,0.6) {$\ve{v_{i+1}}$};
\node[imageLabel] at (0.62,0.85) {$\ve{v_{i+2}}$};
\node[imageLabel] at (0.8,0.2) {$Obs$};
][
\node[imageLabel] at (0.2,0.1) {$\ve{v_i}$};
\node[imageLabel] at (0.43,0.6) {$\ve{v_{i+1}}$};
\node[imageLabel] at (0.62,0.85) {$\ve{v_{i+2}}$};
\node[imageLabel] at (0.8,0.2) {$Obs$};
\node[imageLabel] (W1) at (0.25,0.3) {$\ve{w_1}$};
\node[imageLabel] (W2) at (0.5,0.75) {$\ve{w_2}$};
\path[imageArrow] (W1) -- (0.3,0.15);
\path[imageArrow] (W2) -- (0.66,0.79);
\node[imageLabel] at (0.8,0.2) {$Obs$};
]
In \cref{fig:sol21} and \cref{fig:sol22} we can see the effects of the
application of this
solution to a piece of the curve. The original pieces of control
polygon are on the left pictures, the triangle
composed of those vertices
collide with the obstacle on the back. The two new vertices $\ve{w_1}$
and $\ve{w_2}$ are added to avoid the collision.

\subsubsection{Complexity considerations}\index{Complexity!Dijkstra's algorithm in $G$}\index{Dijkstra in $G$!complexity}
For this solution we have still the costs of \cref{eq:costGraph} and
\cref{eq:costPruning} for
the creation and pruning of the graph $G$. In addition we need to
apply Dijkstra's
algorithm in $G$ for obtaining $P$ with a cost \cite{bondy}\cite{lavalle}
\begin{equation*}
  \bigO(|E|+|V|\log |V|).
\end{equation*}
For \cref{eq:numV} \cref{eq:numE} this cost is equal to
\newcommand{\eqCostDijkstraG}{\ensuremath{\bigO(k|\obsSet|+|\obsSet|\log |\obsSet|)}}
\begin{equation}\label{eq:costDijkstraG}
  \eqCostDijkstraG
\end{equation}
and if we make the assumption of $k$ constant we have a cost
\begin{equation*}
  \bigO(|\obsSet|\log |\obsSet|).
\end{equation*}

For checking and removing the collisions in the path we need to
consider every face of obstacle in $\obsSet$ for every
triangle in $P$. The cost for doing this is\footnote{If
  $\#\acp{OTF}=\bigO(|\obsSet|)$ - i.e. the
  number of \acp{OTF} don't grow faster than the number of obstacles.}
$\bigO(|P|\cdot|\obsSet|)$ where $|P|$ means the number of vertices
in $P$. In the worst case
$|P|=\bigO(|V|)=\bigO(|\obsSet|)$ so we have a cost
\newcommand{\eqCostCleanPath}{\ensuremath{\bigO(|P|\cdot|\obsSet|)=\bigO(|\obsSet|^2)}}
\begin{equation}\label{eq:costCleanPath}
  \eqCostCleanPath
\end{equation}

Summing up all the costs we have 
\newcommand{\eqCostTotalTwo}{\ensuremath{\bigO(k|\obsSet|^2)}}
\begin{equation}\label{eq:costTotalTwo}
  \eqCostTotalTwo
\end{equation}
and if we consider $k$ constant
\newcommand{\eqCostTotalTwoK}{\ensuremath{\bigO(|\obsSet|^2)}}
\begin{equation}\label{eq:costTotalTwoK}
  \eqCostTotalTwoK .
\end{equation}

\begin{table}
  \centering
  \begin{tabular}{|l|c|r|}
    \hline
    Description&Cost&Reference\\
    \hline
    \hline
    Creation of $G$&\eqCostGraph&\cref{eq:costGraph}\\
    Pruning of $G$&\eqCostPruning&\cref{eq:costPruning}\\
    Routing in $G$&\eqCostDijkstraG&\cref{eq:costDijkstraG}\\
    Clean path&\eqCostCleanPath&\cref{eq:costCleanPath}\\
    \hline
    Total&\eqCostTotalTwo&\cref{eq:costTotalTwo}\\
    Total ($k$ costant)&\eqCostTotalTwoK&\cref{eq:costTotalTwoK}\\
    \hline
  \end{tabular}
  \caption{Summary of the costs for solution two}
  \label{tab:costsSol2}
\end{table}
On \cref{tab:costsSol2} we summarize all the terms that contribute to
the total costs, and the total cost itself.

The cost is comparable with the one of the first solution. Furthermore,
also in 
this case we can divide the algorithm in two parts:
\begin{enumerate}
\item first we can construct $G$ only
  once with cost $\bigO(|\obsSet|^2)$;
\item then we can use it for different
  situations with cost $\bigO(|\obsSet|\log|\obsSet|+|P|\cdot|\obsSet|)$.
\end{enumerate}

\section{Degree increase}\label{sec:degreeInc}\index{Degree
  increase}\index{\bss!higher degree}
Until now we have assumed of dealing only with quadratic \bss{} -
i.e. of degree $m$ - because
in that case,
for the \ac{CHP} (\cref{sec:convexHull}), we need to check
intersections only between  two triangles (one belonging to $P$ and the
other to \acp{OTF}). If we want to use higher degree
curves we can modify the
previous algorithms for dealing with polyhedral convex hulls, but this
implies a complexity increasing.

We are interested in increasing the degree for achieving smooth
curves with continue curvature and torsion. We adopted a compromise:
we adapt the path obtained from the previous algorithms adding
vertices and forcing the curve to remain in the same convex
hull. However this approach have the drawback that we cannot achieve a
good torsion\footnote{We can improve this with the post process.}
because the curve changes plane in an inflection point of
the curvature.

We modify 
\begin{equation*}
P=(\ve{v_0},\dots,\ve{v_n})  
\end{equation*}
adding a certain number of aligned new vertices
$(\ve{w_0},\ve{w_1},\dots)$ between each pair 
$(\ve{v_i},\ve{v_{i+1}})$ of vertices in $P$ for $i=0,\dots,n-1$. The
number of $\ve{w_j}$
between each pair $(\ve{v_i},\ve{v_{i+1}})$ depends on the desired
grade of the curve. In fact we need $m-2$ new vertices between each
$(\ve{v_i},\ve{v_{i+1}})$ for 
  \bs curves of degree $m$.
Thus the final modified path for a \bs curve of degree $m\ge 3$ is
\begin{equation*}
  \tilde{P}=(\ve{v_0},\ve{w_0},\dots,\ve{w_{m-3}},\ve{v_1},\dots,\ve{v_i},\ve{w_{i(m-2)}},\dots,\ve{w_{(i+1)(m-2)-1}},\ve{v_{i+1}},\dots,\ve{v_n}).
\end{equation*}

This strategy  is used in the project only for lifting the degree from $2$ to $3$ or $4$.

\begin{myfig}{Increase the degree $m$ from $2$ to $4$.}{fig:highDegree}
  \begin{tikzpicture}
    \coordinate (a) at (-2,0);
    \coordinate (b) at (1,0);
    \coordinate (c) at (3,3);
    \coordinate (d) at (5,4);
    \coordinate (e) at (7,1);
    \coordinate (f) at (9,2);
    \coordinate (g) at (12,2);

    \coordinate (ab1) at ($ (a)!0.33!(b) $);
    \coordinate (ab2) at ($ (b)!0.33!(a) $);
    \coordinate (bc1) at ($ (b)!0.33!(c) $);
    \coordinate (bc2) at ($ (c)!0.33!(b) $);
    \coordinate (cd1) at ($ (c)!0.33!(d) $);
    \coordinate (cd2) at ($ (d)!0.33!(c) $);
    \coordinate (de1) at ($ (d)!0.33!(e) $);
    \coordinate (de2) at ($ (e)!0.33!(d) $);
    \coordinate (ef1) at ($ (e)!0.33!(f) $);
    \coordinate (ef2) at ($ (f)!0.33!(e) $);
    \coordinate (fg1) at ($ (f)!0.33!(g) $);
    \coordinate (fg2) at ($ (g)!0.33!(f) $);

    \foreach \x/\y/\z in {a/b/c,b/c/d,c/d/e,d/e/f,e/f/g}{
      \path[convexHull] (\x) -- (\y) -- ($ (\y)!0.33!(\z) $) -- (\x);
      \path[convexHull] ($ (\x)!0.33!(\y) $) -- (\y) -- ($ (\z)!0.33!(\y) $) -- ($ (\x)!0.33!(\y) $);
      \path[convexHull] ($ (\y)!0.33!(\x) $) -- (\y) -- (\z) -- ($ (\y)!0.33!(\x) $);
    }

    \foreach \x/\y/\z in {a/b/c,b/c/d,c/d/e,d/e/f,e/f/g}{
      \draw[convexHullBord] (\x) -- ($ (\y)!0.33!(\z) $);
      \draw[convexHullBord] ($ (\x)!0.33!(\y) $) -- ($ (\z)!0.33!(\y) $);
      \draw[convexHullBord] ($ (\y)!0.33!(\x) $) -- (\z);
    }

    \draw[controlPoly] (a) -- (b) -- (c) -- (d) -- (e) -- (f) -- (g);

    \foreach \p in {a,b,c,d,e,f,g}
    \filldraw[controlVert] (\p) circle (2pt);

    \foreach \g in {ab1,ab2,bc1,bc2,cd1,cd2,de1,de2,ef1,ef2,fg1,fg2}
    \filldraw[controlVertHigh] (\g) circle (2pt);

    \node[below] at (a) {$\ve{v_{0}}$};
    \node[below] at (b) {$\ve{v_{1}}$};
    \node[above left] at (c) {$\ve{v_{2}}$};
    \node[above] at (d) {$\ve{v_3}$};
    \node[below right] at (e) {$\ve{v_4}$};
    \node[above] at (f) {$\ve{v_5}$};
    \node[below] at (g) {$\ve{v_6}$};

    \node[below] at (ab1) {$\ve{w_0}$};
    \node[below] at (ab2) {$\ve{w_1}$};
    \node[below right] at (bc1) {$\ve{w_2}$};
    \node[below right=2pt] at (bc2) {$\ve{w_3}$};
    \node[above] at (cd1) {$\ve{w_4}$};
    \node[above] at (cd2) {$\ve{w_5}$};
    \node[above right] at (de1) {$\ve{w_6}$};
    \node[below left=2pt] at (de2) {$\ve{w_7}$};
    \node[below right] at (ef1) {$\ve{w_8}$};
    \node[below right=2pt] at (ef2) {$\ve{w_9}$};
    \node[above] at (fg1) {$\ve{w_{10}}$};
    \node[above] at (fg2) {$\ve{w_{11}}$};
  \end{tikzpicture}
\end{myfig}
In \cref{fig:highDegree} is visible an example of path
\begin{equation*}
  P=(\ve{v_0},\ve{v_1},\ve{v_2},\ve{v_3},\ve{v_4},\ve{v_5},\ve{v_6}).
\end{equation*}
In green we have the vertices of $P$, in red the added vertices and
the cyan area is the convex hull of the final curve.

We want to adapt $P$ to quartic \bs curves, so we need to add two new
vertices between each pair of vertices $(\ve{v_i},\ve{v_{i+1}})$ for
$i=0,\dots,6$. Those new vertices are
\begin{equation*}
  (\ve{w_0},\ve{w_1},\ve{w_2},\ve{w_3},\ve{w_4},\ve{w_5},\ve{w_6},\ve{w_7},\ve{w_8},\ve{w_9},\ve{w_{10}},\ve{w_{11}}).
\end{equation*}

Note that, with this algorithm, when we increase the degree from $2$
to $m\ge 3$ we have that the convex hull containing a \bs curve of
degree $m$ in
$\tilde{P}$ is a subset of the convex hull containing a \bs curve
of degree $2$
in $P$. This is because the polyhedrons of consecutive $m+1$ vertices in
$\tilde{P}$ collapses in triangles contained inside the triangles
of consecutive vertices in $P$. For instance in \cref{fig:highDegree}
the convex hull of the first $5$ vertices
$\ve{v_0},\ve{w_0},\ve{w_1},\ve{v_1},\ve{w_2}$ of $\tilde{P}$
coincides with the
triangle $\triangle \ve{v_0}\ve{v_1}\ve{w_2}$ that is contained inside
the triangle $\triangle \ve{v_0}\ve{v_1}\ve{v_2}$ of the first $3$
vertices of $P$.

One effect of the application of this method is that a curve of
degree $m$ in $\tilde{P}$ will touch
every segment of the original control polygon $P$. This is because adding
$m-2$ aligned vertices between each pair $(\ve{v_i},\ve{v_{i+1}})$
will result in $m$ aligned vertices on each original segment
(\cref{sec:alignedVertices}).

\section{Knots selection}\label{sec:knotSel}\index{\bss!knot selection}
In the previous sections we never discussed the criterion adopted for
fixing the extended knot vector $T$ associated to the \bs curve.
\begin{equation*}
  T=\{t_0,\dots,t_{m-1},t_{m},\dots,t_{n+1},t_{n+2},\dots,t_{n+m+1}\}
\end{equation*}
In this section we discuss two
methods that we implemented.

First of all, we want that
the curve interpolates
the chosen start and end points, that correspond to the extremes
$\ve{v_0}$ and $\ve{v_n}$ of the extracted path $P$. We saw in
\cref{sec:clamped} that we can archive such interpolation if we impose
\begin{equation}\label{eq:externalKnotsFix}
  \begin{split}
    &t_0 = t_1 = \dots = t_{m} = a\\
    &t_{n+1} = t_{n+2} = \dots = t_{n+m+1} = b
  \end{split}
\end{equation}
where $a$ and $b$ are the extremes of the parametric domain of
the curve.

The constraint of \cref{eq:externalKnotsFix} is a mandatory
choice, so we cannot change it. Regarding the parametric domain, we
chose it to be $[0,1]$ because changing the extremes do not change
the behavior of the curve, only changing the ratios of the distances
between the knots is effective \cite{farin}. We still need to chose how to select 
the inner $n-m$ knots $t_{m+1},\dots,t_n$, and we developed two different
ways of doing it:
\begin{enumerate}[label=\textbf{method \arabic*}]
\item\label[void]{en:uniform} Use a uniform partition where $t_i-t_{i-1}=c$ for
  $i=m+1,\dots,n+1$ for $c$ constant;
\item\label[void]{en:adaptive} Use an adaptive partition, where we try
  to make dense knots in
  correspondence of points on the curve where we have dense control
  vertices.
\end{enumerate}

\cref{en:uniform} is the easiest way of choosing a knot vector
and is common as first choice in textbooks \cite{farin}\cite{docarmo},
but it has the disadvantage of ignoring the geometry of the curve
\cite{farin}. The steps to do for accomplish \cref{en:uniform} are quite
straightforward: we need to pick the nodes
\begin{equation*}
  \frac{i}{n-m+1}
\end{equation*}
for $i=1,\dots,n-m$. Thus we concentrate on \cref{en:adaptive}.

\begin{myfig}{Optimal case for a quadratic curve (we want uniform partition).}{fig:adaptive1}
  \begin{tikzpicture}
    \coordinate (v0) at (0,0);
    \coordinate (v1) at (2,0);
    \coordinate (v2) at (4,0);
    \coordinate (v3) at (6,0);
    \coordinate (v4) at (8,0);
    \coordinate (v5) at (10,0);

    \coordinate (t0) at (0,-1);
    \coordinate (t4) at (10,-1);
    \coordinate (t1) at ($ (t0)!0.25!(t4) $);
    \coordinate (t2) at ($ (t0)!0.5!(t4) $);
    \coordinate (t3) at ($ (t0)!0.75!(t4) $);

    \foreach \v/\w in {v0/w0,v1/w1,v2/w2,v3/w3,v4/w4,v5/w5}{
      \coordinate (\w) at ($(t0)!(\v)!(t4)$);
      \draw[controlToKnot] (\v) -- (\w);
    }    

    \draw[controlPoly] (v0) -- (v1) -- (v2) -- (v3) -- (v4) -- (v5);
    \draw[knotPoly] (t0) -- (t1) -- (t2) -- (t3) -- (t4);

    \foreach \v/\i in {v0/0,v1/1,v2/2,v3/3,v4/4,v5/5}{
      \filldraw[controlVert] (\v) circle (2pt);
      \node[above] at (\v) {$\ve{v_{\i}}$};
    }

    \foreach \t/\j/\pos in {t0/{0,1,2}/below,t1/3/above,t2/4/above,t3/5/above,t4/{6,7,8}/below}{
      \filldraw[knot] (\t) circle (2pt);
      \node[\pos] at (\t) {$t_{\j}$};
    }

    \foreach \w/\j in {w1/1,w2/2,w3/3,w4/4}{
      \node[below] at (\w) {$\nu_{\j}$};
    }
    \node[below=15pt] at (w0) {$\nu_0$};
    \node[below=15pt] at (w5) {$\nu_5$};
    \node[left=20pt] at (v0) {$P$};
    \node[left=20pt] at (t0) {$\tau$};

    %\filldraw[color=yellow] ($ (w1)!0.25!(w2) $) circle (2pt);
  \end{tikzpicture}
\end{myfig}
\begin{myfig}{General case for a quadratic(same distances between
    $t_i$ and enclosing $\nu_j$, $\nu_{j+1}$ as \cref{fig:adaptive1}).}{fig:adaptive2}
  \begin{tikzpicture}
    \coordinate (v0) at (0,0);
    \coordinate (v1) at (1,0);
    \coordinate (v2) at (2,0);
    \coordinate (v3) at (4,0);
    \coordinate (v4) at (8,0);
    \coordinate (v5) at (10,0);

    \coordinate (t0) at (0,-1);
    \coordinate (t4) at (10,-1);

    \foreach \v/\w in {v0/w0,v1/w1,v2/w2,v3/w3,v4/w4,v5/w5}{
      \coordinate (\w) at ($(t0)!(\v)!(t4)$);
      \draw[controlToKnot] (\v) -- (\w);
    }    

    \coordinate (t1) at ($ (w1)!0.25!(w2) $);
    \coordinate (t2) at ($ (w2)!0.5!(w3) $);
    \coordinate (t3) at ($ (w3)!0.75!(w4) $);

    \draw[controlPoly] (v0) -- (v1) -- (v2) -- (v3) -- (v4) -- (v5);
    \draw[knotPoly] (t0) -- (t1) -- (t2) -- (t3) -- (t4);

    \foreach \v/\i in {v0/0,v1/1,v2/2,v3/3,v4/4,v5/5}{
      \filldraw[controlVert] (\v) circle (2pt);
      \node[above] at (\v) {$\ve{v_{\i}}$};
    }

    \foreach \t/\j/\pos in {t0/{0,1,2}/below,t1/3/above,t2/4/above,t3/5/above,t4/{6,7,8}/below}{
      \filldraw[knot] (\t) circle (2pt);
      \node[\pos] at (\t) {$t_{\j}$};
    }

    \foreach \w/\j in {w1/1,w2/2,w3/3,w4/4}{
      \node[below] at (\w) {$\nu_{\j}$};
    }
    \node[below=15pt] at (w0) {$\nu_0$};
    \node[below=15pt] at (w5) {$\nu_5$};
    \node[left=20pt] at (v0) {$P$};
    \node[left=20pt] at (t0) {$\tau$};
  \end{tikzpicture}
\end{myfig}
We started from the idea that if we have a control polygon with
uniformly-spaced vertices -
i.e. $\norm{\ve{v_1}-\ve{v_0}}=\norm{\ve{v_2}-\ve{v_1}}=\cdots=\norm{\ve{v_n}-\ve{v_{n-1}}}$
- then we agree on a uniform partition of the knots
($t_{m+1}-t_m=t_{m+2}-t_{m+1}=\cdots=t_{n+1}-t_n$). In
\cref{fig:adaptive1} there is an example of a quadratic \bs curve with
uniformly-spaced control polygon. The above segment is a
\emph{rectified} 
visualization of the control polygon with six control
vertices
$\ve{v_0},\dots,\ve{v_5}$. The segment below represents the
partition of the domain from $a$ (on the left) to $b$
(on the right), with the projections $\nu_0,\dots,\nu_5$ of the control
vertices,
scaled in length to the parametric domain axis\footnote{$\ve{v_0}$ is
  projected to $a$, $\ve{v_5}$ is projected to $b$, and the ratios
  between the distances between vertices are preserved.}, and the
knots $t_0,\dots,t_8$ on it.

Starting from this situation, if
we have a generic control polygon with segments of different length as
in \cref{fig:adaptive2}, then we want that each $t_i$ keep the same
distance, in ratio, between the surrounding $\nu_j$ and $\nu_{j+1}$,
respect to the optimal case. For instance in \cref{fig:adaptive1}
$\frac{t_3-\nu_1}{\nu_2-\nu_1}=\frac{1}{4}$ and
$\frac{\nu_2-t_3}{\nu_2-\nu_1}=\frac{3}{4}$, this means that in
\cref{fig:adaptive2} the same values must be preserved.

The problem now is how to calculate the values of $t_i$ in the general
case. We consider only the inner part $\tau$ of the partition vector,
included the extremes
\begin{equation*}
  \tau_i = t_{i+m}\qquad i=0,\dots,n-m+1
\end{equation*}
where $\tau_0=a=0$ and $\tau_{n-m+1}=b=1$. In \cref{fig:adaptive1} and
\cref{fig:adaptive2}
$\tau=(t_2,t_3,t_4,t_5,t_6)$. Now we calculate the positions of all
$\tau_i$ respect to the $\nu_j$ in the \emph{optimal} case. We can
achieve that using as unit the uniform distance $\nu_j-\nu_{j-1}$ for
calculating the positions of $\tau_i$. Purposely, we calculate
\begin{equation}\label{eq:adaptivePos}
  \tau_i^\nu=\frac{n}{n-m+1}\cdot i\qquad i=0,\dots,n-m+1
\end{equation}
obtaining the numbers $\tau_i^\nu$ whose integer part
$\lfloor\tau_i^\nu\rfloor$ represents the index $j$ of the
$\nu_j$ that is to the left of $\tau_i$, and the decimal part
$(\tau_i^\nu-\lfloor\tau_i^\nu\rfloor)$ represents the distance from
it: $\frac{\tau_i-\nu_j}{\nu_{j+1}-\nu_j}$.

Now we calculate the projections $\nu_i$ in the
\emph{generic} case.
We start calculating the incremental distances between
the vertices
\begin{equation*}
  \begin{cases}
    d_0=0&\\
    d_i=d_{i-1}+\norm{\ve{v_i}-\ve{v_{i-1}}}&\qquad i=1,\dots,n
  \end{cases}
\end{equation*}
and, remembering that the parametric domain is $[0,1]$, we have
\begin{equation}\label{eq:adaptiveProj}
  \nu_i=\frac{d_i}{d_n}\qquad i=0,\dots,n.
\end{equation}

Now, using the positions in \cref{eq:adaptivePos} on the projection in
\cref{eq:adaptiveProj}, we obtain the values
\begin{equation*}
  \tau_i=\nu_{\lfloor\tau_i^\nu\rfloor}+(\tau_i^\nu-\lfloor\tau_i^\nu\rfloor)(\nu_{\lfloor\tau_i^\nu\rfloor+1}-\nu_{\lfloor\tau_i^\nu\rfloor})\qquad i=0,\dots,n-m+1.
\end{equation*}
Finally, adding the duplicated knots, we obtain
\begin{equation*}
  t_i=\tau_{\min(n-m+1,\ \max(0,\ i-m))}\qquad i=0,\dots,n+m+1.
\end{equation*}

\section{Post processing}\label{sec:postPro}\index{Post process}
The purpose of the post processing phase is to try to simplify the
path $P=(\ve{v_0},\dots,\ve{v_n})$ obtained in the previous phase
removing useless vertices, in order
to achieve a smoother path.

\begin{algo}{Post processing algorithm on path $P$.}{alg:postProcess}
  \Procedure{postProcess}{$P$}
  \For{$i\Ass 1,n-1$}
  \If{$i=1$ \IfOr \IfNot $intersect\acs{OTF}(\triangle\ve{v_{i-2}}\ve{v_{i-1}}\ve{v_{i+1}})$}
  \If{$i=n-1$ \IfOr \IfNot $intersect\acs{OTF}(\triangle\ve{v_{i-1}}\ve{v_{i+1}}\ve{v_{i+2}})$}
  \State $P\Ass P\setminus\{\ve{v_i}\}$
  \EndIf
  \EndIf
  \EndFor
  \EndProcedure
\end{algo}
For obtaining this we realized \cref{alg:postProcess} that
iterates through all the vertices, except the extremes, and for each
$v_i$ checks if it can be removed without consequences. With
consequences we mean that removing $v_i$ would cause that a triangle
in $P$ intersect one of the \acp{OTF}.

\begin{myfig}{Example of post process check that removes $\ve{v_i}$.}{fig:postProcess}
  \begin{tikzpicture}
    \coordinate (l1) at (0,0);
    \coordinate (a) at (1,0);
    \coordinate (b) at (3,3);
    \coordinate (c) at (5,4);
    \coordinate (d) at (7,1);
    \coordinate (e) at (9,2);
    \coordinate (l2) at (10,2);
    \coordinate (o1) at (4,0);
    \coordinate (o2) at (5,1.5);
    \coordinate (o3) at (6,0);

    \path[convexHull] (a) -- (b) -- (d) -- (a);
    \path[convexHull] (b) -- (d) -- (e) -- (b);

    \draw[controlPoly] (a)  -- (b);
    \draw[controlPoly] (d)  -- (e);
    \draw[controlPolyTract] (l1) -- (a);
    \draw[controlPolyTract] (e) -- (l2);
    \draw[controlPolyTractHigh] (b) -- (d);
    \draw[controlPolyHigh] (b) -- (c) -- (d);

    \path[obstacle] (o1) -- (o2) -- (o3) -- (o1);
    \node at (barycentric cs:o1=0.3,o2=0.3,o3=0.3) {\acs{OTF}};

    \foreach \p in {a,b,d,e}
    \filldraw[controlVert] (\p) circle (2pt);
    \filldraw[controlVertHigh] (c) circle (3pt);

    \node[below] at (a) {$\ve{v_{i-2}}$};
    \node[above left] at (b) {$\ve{v_{i-1}}$};
    \node[above] at (c) {$\ve{v_i}$};
    \node[below right] at (d) {$\ve{v_{i+1}}$};
    \node[above] at (e) {$\ve{v_{i+2}}$};
  \end{tikzpicture}
\end{myfig}
For clarifying the concept consider \cref{fig:postProcess} that is a
simplification in 2-dimensional space of the real case in
3-dimensional space. The path to process
is
\begin{equation*}
  P=(\dots,\ve{v_{i-2}},\ve{v_{i-1}},\ve{v_{i}},\ve{v_{i+1}},\ve{v_{i+2}},\dots)
\end{equation*}
and we are
considering removing $\ve{v_i}$ obtaining a modified path
\begin{equation*}
  \tilde{P}=(\dots,\ve{v_{i-2}},\ve{v_{i-1}},\ve{v_{i+1}},\ve{v_{i+2}},\dots).
\end{equation*}
Before doing this we need to check if any triangle in $\tilde{P}$
intersects any \ac{OTF}. In detail we need to check only the two
triangles $\triangle\ve{v_{i-2}}\ve{v_{i-1}}\ve{v_{i+1}}$ and
$\triangle\ve{v_{i-1}}\ve{v_{i+1}}\ve{v_{i+2}}$ because the other
triangles in $\tilde{P}$ are already present in $P$. For instance
the obstacle in the figure do not intersects anyone of the triangles in
$P$, but it intersects $\triangle\ve{v_{i-2}}\ve{v_{i-1}}\ve{v_{i+1}}$ in
$\tilde{P}$.

\subsubsection{Complexity considerations}\index{Post process!complexity}\index{Complexity!post process}
For every vertex of $P$ we need to check if two triangles intersect
with an \ac{OTF}, so we have a complexity of
\begin{equation*}
  \bigO(|P|\cdot|\obsSet|)=\bigO(|\obsSet|^2)
\end{equation*}
where $\obsSet$ is the set of obstacles and $|P|$ is the number of vertices
in $P$.

\section{Third solution: Simulated Annealing}\label{sec:inter3}\index{\acf{SA}}
The solutions proposed in \cref{sec:inter1} and \cref{sec:inter2} have two
problems in common:
\begin{itemize}
\item both reject configurations in a prudent way
  considering only the control polygon;
\item and both don't optimize neither
  length nor other quantities.
\end{itemize}
Anyway such solutions have also the benefit that:
\begin{itemize}
\item they produce paths that are obstacle-free from construction;
\item the application of the post processing allows often a reduction
  of the curve length.
\end{itemize}

In this section we describe a third
approach considered in the project, an approach based on a
probabilistic computation.
    
We can see the problem of finding the shortest path as a constrained
optimization problem, where a certain configuration of the control
vertices (and
consequently the \bs) is the state of the system, and we want to
minimize both the length of the control polygon (and consequently the
\bs\footnote{We give to the user also the possibility of selecting the
  arc length as quantity to minimize.}) and the peak in curvature and torsion of the \bs, under
the constraint that the \bs must not intersect the obstacles. We
are interested in optimizing both length and curvature and torsion
peaks because we want a path that is short but also fair.

\subsection{\acf{LR} applied to the project}\index{\acf{LR}}
We can apply the concept explained in \cref{sec:lagrangianRelaxation}
to the project.

The variable space $X$ is composed of all possible
configuration of the path, or in other words is the vector
$P=(\ve{v_1},\dots,\ve{v_n})$ of all $n$ ordered
vertices $\ve{v_i}=(x_i,y_i,z_i)$ of the
path. The \cref{eq:opt} can be formulated as follows,
\begin{equation*}
  \begin{aligned}
    & \underset{P}{\text{minimize}}
    & & \alpha\cdot maxCurv(P)+\beta\cdot
    maxTors(P)+\gamma\cdot normLen(P) \\
    & \text{subject to}
    & & \left|bspline(P)\cap \bigcup_{i\in I}obstacle_i\right| = 0,
  \end{aligned}
\end{equation*}
where $maxCurv(P)$ is the peak of curvature of the \bs
constructed using $P$ as control polygon,
$maxTors(P)$ is the peak in absolute value of the torsion and
$normLen(P)$ is the length of the control polygon
$P$ normalized as percentage of the length of the initial
status\footnote{If the user chooses to minimize the
  arc length, then $normLen(P)$ becomes the length of the \bs curve.}
. $\alpha$, $\beta$ and $\gamma$ are fixed
coefficients used for giving different weights in the optimization
process to 
the curvature peak, torsion peak and length. The normalization of
length is necessary for decoupling the weight of the length from the
length of path.

Curvature and torsion, and thus also the
relative peaks, are obtained in a discrete form. The \bs curve is
tabulated in a number of points that depends on the length of $P$
by a constant, then for each point the curvature and torsion values
are calculated.

Regarding the constraint, $bspline(P)$
is the set of points of the \emph{\bs}, using $P$ as 
control polygon, and 
$obstacle_i$ is the area of the $i^{th}$ of $m$ obstacles, and
$I=\{1,\dots,m\}$.

We need to build now the Lagrangian function corresponding to
\cref{eq:lagrangianFun}, for conciseness we define the function
\begin{equation}\label{eq:gainLag}
  gain(P) = \alpha\cdot maxCurv(P)+\beta\cdot
    maxTors(P)+\gamma\cdot normLen(P)
\end{equation}
the constraint function is not negative, and is calculated as the
ratio
\begin{equation}\label{eq:constraintLag}
constraint(P) = \frac{\left|\ \{\ve{p} \in spline(P)\ : \exists i
    \text{ s.t. } \ve{p}\in
    obstacle_i\}\ \right|}{\left|\ \{\ve{p} \in
    spline(P)\}\ \right|}.
\end{equation}


The points $\ve{p}$ of the spline are calculated in a discrete
form, like curvature and torsion. Thus the constraint depends on the
tabulation of the curve and
it is also possible to have borderline cases where the
constraint doesn't reflect the real situation\footnote{For instance if
  we have very thin obstacles, a curve can pass through it having few
  points (or even none) of it inside them.}.

The
function in \cref{eq:constraintLag} is not negative, thus the
Lagrangian function corresponding to 
\cref{eq:lagrangianFun} is
\begin{equation}\label{eq:lagrangianFunProj}
    L_d(P,\lambda)=gain(P)+\lambda\cdot constraint(P).
\end{equation}

\subsection{Annealing phase}
The target of the simulated annealing phase is to find the minimum
saddle point in
the curve represented by the
\cref{eq:lagrangianFunProj}.
\begin{algo}{Annealing}{alg:annealing}
  \Procedure{annealing}{$\ve{x}$}
  \State $\lambda\Ass initialLambda$\label{alg:annealing:initialize}
  \State $T\Ass initialTemperature$\label{alg:annealing:initialize2}
  \While{not $terminationCondition()$}\label{alg:annealing:while}
  \ForAll{number of trials}\label{alg:annealing:for}
  \State $changeLambda\Ass\True$ with $changeLambdaProb$\label{alg:annealing:lambdaProb}
  \If{$changeLambda$}
  \State $\lambda'\Ass neighbour(\lambda)$\label{alg:annealing:changeLambda}
  \State $\lambda\Ass \lambda'$ with probability $\me^{-([energy(\ve{x},\lambda)-energy(\ve{x},\lambda')]^+/T)}$
  \Else
  \State $\ve{x}'\Ass neighbour(\ve{x})$\label{alg:annealing:changeX}
  \State $\ve{x}\Ass \ve{x}'$ with probability $\me^{-([energy(\ve{x}',\lambda)-energy(\ve{x},\lambda)]^+/T)}$
  \EndIf
  \EndFor
  \State $T\Ass T\cdot warmingRatio$\label{alg:annealing:cooling}
  \EndWhile
  \EndProcedure
\end{algo}

The \cref{alg:annealing} is the annealing process, the input is the
initial status of the system $\ve{x}$ - i.e. the initial configuration
of the control polygon.
\begin{enumerate}
\item $\lambda$ and the
  temperature are initialized on
  \cref{alg:annealing:initialize} and \cref{alg:annealing:initialize}
  respectively;
\item the \emph{while} on
  \cref{alg:annealing:while} is the main loop and the terminating
  condition is given by a minimum temperature or a minimum variation of
  energy between two iterations;
\item the \emph{for} at
  \cref{alg:annealing:for} repeats the annealing move for a certain
  number of trials, on each iteration the algorithm probabilistically
  tries to make a move of the state of the system;
  \begin{itemize}
  \item first on
    \cref{alg:annealing:lambdaProb} it makes the choice if moving in the
    Lagrangian space or in the space of the path;
  \item after that, based on the previous
    choice, the algorithm tries probabilistically to move the system
    in a neighbouring
    state: in the
    Lagrangian space at
    \cref{alg:annealing:changeLambda} or in the path space at
    \cref{alg:annealing:changeX};
  \end{itemize}
\item finally at the end of every trial set,
  at \cref{alg:annealing:cooling}, the temperature $T$ is cooled by
  a certain factor.
\end{enumerate}

The termination condition in \cref{alg:annealing:while} is triggered by a
minimum variation of energy $\Delta energy$ between two consecutive
iterations of the cycle. Also the termination is triggered when a
minimum temperature is reached, this is for impose a limit on the
number of cycles.

The choice of the neighbour is made
probabilistically in the meaning that if the energy increases in the
Lagrangian space or decreases in the path space, then the probability of
choosing the new state is 1. If the energy decreases in the Lagrangian
space or increases in the path space, then the new state is accepted
with a probability that is\footnote{Note that $[x]^+=\max(0,x)$.}:
$$\exp(-\frac{\Delta energy}{T}).$$

The $neighbour$ function chooses a neighbour of the state and it is
defined depending on the input:
\begin{itemize}
  \item a neighbour of $\lambda$ is a value that is equal to $\lambda$
    plus a perturbation uniformly in range $[-maxLambdaPert, maxLambdaPert]$;
  \item a neighbour of the path is obtained by randomly picking one of
    the vertices $\ve{v_i}$, except the extremes $\ve{v_0}$ and $\ve{v_n}$,
    then choosing uniformly a direction and a distance
    in a specific range, and finally moving $\ve{v_i}$ by
    the chosen values.
\end{itemize}

The $energy$ function is equivalent to $L_d$ in the
\cref{eq:lagrangianFunProj}:
\begin{equation}
  \label{eq:annealingEnergy}
  energy(\ve{x},\lambda)=gain(P)+\lambda\cdot constraint(P).
\end{equation}

The annealing process
finds a saddle point by probabilistically increasing the energy, when
$\lambda$ is moved, and 
decreasing the energy when the points are moved.

\subsubsection{Complexity considerations}\index{\acf{SA}!complexity}\index{Complexity!\acf{SA}}
For this solution we have still the costs of \cref{eq:costGraph} and
\cref{eq:costPruning} for
the creation and pruning of the graph $G$. In addition we need to
apply Dijkstra's
algorithm in $G$ for obtaining the initial path $P$ with the cost of
\cref{eq:costDijkstraG}.

Regarding the annealing phase, for each \emph{step} (an
iteration of \cref{alg:annealing:while} in \cref{alg:annealing}) we
have a fixed number of \emph{trials} (the iterations of \cref{alg:annealing:for}). For each trial we need to
calculate the value of the energy, \cref{eq:annealingEnergy}, that is
the sum of the gain and the constraint.

For the gain, \cref{eq:gainLag}, we need to calculate the values of
curvature and torsion for every tabulated point. Furthermore there is
also a cost\footnote{Only if
  the user do not choose to minimize the arc length.} of
$\bigO(|P|)$ for
calculating the length of the control polygon. The cost for
calculating the gain is thus
\begin{equation*}
  \bigO(|Sp|+|P|)
\end{equation*}
where $Sp$ is the set of the tabulated points of the curve. The number
of points in $Sp$ depends on the length of the control polygon
$len(P)$. Thus
we have a cost of $\bigO(len(P)+|P|)$, but in the worst case
$|P|=\bigO(|V|)=\bigO(|\obsSet|)$, thus the cost is
\newcommand{\eqCostGain}{\ensuremath{\bigO(len(P)+|P|)=\bigO(len(P)+|\obsSet|)}}
\begin{equation}
  \label{eq:costGain}
  \eqCostGain.
\end{equation}

Regarding the constraint, \cref{eq:constraintLag}, we need to calculate if
every point 
of the curve is inside an obstacle. This means a cost of
\newcommand{\eqCostConstraint}{\ensuremath{\bigO(len(P)|\obsSet|)}}
\begin{equation}
  \label{eq:costConstraint}
  \eqCostConstraint.
\end{equation}

The total cost for the calculation of the annealing phase is thus
\begin{equation*}
\bigO(\#steps\cdot\#trials\cdot(len(P)|\obsSet|)),
\end{equation*}
but the number of steps and trials are bounded by
constants\footnote{Although such constants can be very high.}. Thus
the cost becomes
\newcommand{\eqCostAnneal}{\ensuremath{\bigO(len(P)|\obsSet|)}}
\begin{equation}
  \label{eq:costAnneal}
  \eqCostAnneal.
\end{equation}

The total cost for the solution is
\newcommand{\eqCostTotalThree}{\ensuremath{\bigO(k|\obsSet|^2+len(P)|\obsSet|)}}
\begin{equation}
  \label{eq:costTotalThree}
  \eqCostTotalThree.
\end{equation}

Likewise the previous solutions, if we have that $k$ is a constant
then the total cost become
\newcommand{\eqCostTotalThreeK}{\ensuremath{\bigO(|\obsSet|^2+len(P)|\obsSet|)}}
\begin{equation}
  \label{eq:costTotalThreeK}
  \eqCostTotalThreeK.
\end{equation}

\begin{table}
  \centering
  \begin{tabular}{|l|c|r|}
    \hline
    Description&Cost&Reference\\
    \hline
    \hline
    Creation of $G$&\eqCostGraph&\cref{eq:costGraph}\\
    Pruning of $G$&\eqCostPruning&\cref{eq:costPruning}\\
    Routing in $G$&\eqCostDijkstraG&\cref{eq:costDijkstraG}\\
    Gain&\eqCostGain&\cref{eq:costGain}\\
    Constraint&\eqCostConstraint&\cref{eq:costConstraint}\\
    Annealing&\eqCostAnneal&\cref{eq:costAnneal}\\
    \hline
    Total&\eqCostTotalThree&\cref{eq:costTotalThree}\\
    Total ($k$ costant)&\eqCostTotalThreeK&\cref{eq:costTotalThreeK}\\
    \hline
  \end{tabular}
  \caption{Resume of the costs for solution three}
  \label{tab:costsSol3}
\end{table}
In \cref{tab:costsSol3} we resumed all the costs. It is
difficult to quantitatively compare the cost of this solution with
the previous 
ones. This is due to the presence of the factor $len(P)$, that depends
on the geometry of the scene. Anyway we can asserts that this solution is
more complex than the previous two by a term
$\bigO(len(P)|\obsSet|)$. 

Furthermore also in this solution
we can divide the algorithm in two parts:
\begin{enumerate}
\item first we can construct only once $G$ with cost $\bigO(|\obsSet|^2)$;
\item then we can use it for different situations with cost
  $|\obsSet|\log|\obsSet|+len(P)|\obsSet|$.
\end{enumerate}


\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../dissertation"
%%% End:
