\documentclass[dissertation.tex]{subfiles}
\begin{document}
\chapter{Algorithm}
In this chapter we analyze step-by-step the algorithms that implements
the different parts of the program. We do this with the help of the
test scene in \cref{fig:empty}.
\image{scrEmpty.png}{Initial scene.}{fig:empty}

The general idea is to use an open \bs curve of a certain degree
interpolating the chosen starting and ending points, whose
control polygon is a suitable modification of a polygonal chain
extracted from a graph
obtained with a Voronoi diagram method. In \cref{sec:polChain} we
explain in detail how to
build such polygonal chain. Before using the chain as a control
polygon for the \bs, it is refined and adjusted - as explained in
detail in \cref{sec:obsAvoid} and \cref{sec:degreeInc} - in order to
ensure that the associated \bs curve has no obstacle
collision. Also we implemented a method for an optional adaptive
arrangment of the breakpoints of the \bs described in
\cref{sec:nodeSel} and an optional post processing for the
simplification of the path described in \cref{sec:postPro}.
\section{Polygonal chain}\label{sec:polChain}
In the first phase the objective is to extract a suitable polygonal chain from
the scene, such that the extremes coincides with the start point $\ve{s}$
and the end point $\ve{e}$. In particular we are interested in short length
chains. We calculate the shortest path
in a graph that is obtained by using an adaptation to three
dimensions of a well known bidimensional method
\cite{bhattacharya}\cite{ho-liu}\cite{seda-pich} that use
Voronoi diagrams as base.

We choose a Voronoi method because it build a structure roughly
equidistant from obstacles, and so we have low probability of
collisions between the curve and the obstacles.

\subsection{Base structure}
First we
start distributing points on the faces of the obstacles and on
an invisible bounding box, as in \cref{fig:sites}.
\image{scrSites.png}{Scene with Voronoi sites.}{fig:sites}
The sites are distributed using a recursive method, for each triangle
of the scene we add three points - one for each
vertex, if not already added before - and then we calculate the area
of the triangle, if the area is bigger than a threshold we decompose
the triangle in four triangles adding three more vertices on the
midpoints of the edges of the original triangle as in
\cref{fig:triangleDec}, and repeating the process recursively for
each new triangle.
\begin{myfig}{Decomposition of a triangle.}{fig:triangleDec}
  \begin{tikzpicture}[scale=2]
    \coordinate (a1) at (1,0);
    \coordinate (b1) at (2,1);
    \coordinate (c1) at (3,0.3);

    \path[obstacle] (a1) -- (b1) -- (c1) -- (a1);

    \coordinate (dist) at (3.5,0);
    \coordinate (a2) at ($ (a1) + (dist) $);
    \coordinate (b2) at ($ (b1) + (dist) $);
    \coordinate (c2) at ($ (c1) + (dist) $);

    \path[obstacle] (a2) -- (b2) -- (c2) -- (a2);
    \foreach \p in {a1,b1,c1,a2,b2,c2}
    \filldraw[site] (\p) circle (2pt); 

    \coordinate (ab) at ($ (a2)!0.5!(b2) $);
    \coordinate (bc) at ($ (b2)!0.5!(c2) $);
    \coordinate (ac) at ($ (a2)!0.5!(c2) $);

    \path[obstacleTract] (ab) -- (bc) -- (ac) -- (ab);

    \foreach \p in {ab,bc,ac}
    \filldraw[siteHigh] (\p) circle (2pt); 
  \end{tikzpicture}
\end{myfig}

We construct the Voronoi diagram using the Fortune's algorithm
\cite{fortune} on
those points as input sites, and we build a graph
$$G=(V,E)$$
using the vertices
of the Voronoi cells as graph nodes in $V$, and the edges of the cells\footnote{Rejecting the
  infinite edges.} as graph edges in $E$. After we prune such graph deleting every edge that
intersect an obstacle face, using the methods explained in \cref{sec:intersections}.
\image{scrGraph.png}{Scene with pruned graph.}{fig:graph}

The result, visible in \cref{fig:graph}, is a graph that embrace the
obstacles like a cobweb where the possible paths on it are roughly
equidistant between the obstacles.

In the bidimensional case the equivalent method implies distributing
the sites in the edges of the polygonal obstacles and then pruning the
graph when an edge of the graph intersect an edge of the obstacle as
in \cref{fig:voronoi2d}.
\image{voronoi2d.png}{Voronoi graph in 2D before pruning (a) and after
  pruning (b).}{fig:voronoi2d}
We decided to extend the method in 3 dimensions distributing points in
the whole faces of obstacles, an alternative would be distributing
points only along the edges of the obstacles.

On the graph obtained $G$ we attach the desired start and end
points $\ve{s}$ and $\ve{e}$, and we can obtain a path between the two points using an
algorithm like Dijkstra \cite{dijkstra}\cite{knuth}. For attaching $\ve{s}$
and $\ve{e}$ we designed two
alternative methods:
\begin{itemize}
\item the first method find the vertex $\ve{v_n}\in V_{vis}\subseteq V$ such
  that $dist(\ve{s},\ve{v_n})\leq dist(\ve{s},\ve{v_i})$, $\forall \ve{v_i}\in V_{vis}$, where
  $V_{vis}=\{\ve{v}\in V |$ the segment $\overline{\ve{s} \ve{v_i}}$ don't intersect
  any obstacle$\}$, then add $\ve{s}$ to $V$ and the edge $(\ve{s},\ve{v_n})$ to $E$;
  similarly for $\ve{e}$;
\item the second method add $\ve{s}$ to $V$ and all the edges $(\ve{s},\ve{v_i})$
  $\forall \ve{v_i}\in V_{vis}$; similarly for $\ve{e}$.
\end{itemize}

Before using that path as a control polygon
we need to take into account the degree of the \bs and the
position of the obstacles, the details are in \cref{sec:obsAvoid} and
\cref{sec:degreeInc}.

\subsubsection{Complexity considerations}
Fortune's algorithm runs in time $\bigO(|Is|\log |Is|)$ \cite{deberg}
where $Is$ is
the set 
of input sites. If we impose a maximum area $A$ for the obstacles
\footnote{Inserting the obstacles in a progressive order, the area of the $i$-th
obstacle cannot be a function $f(i)$ of the number of
the obstacles} then $|Is|=\bigO(|Ob|)$ where $Ob$ is the set of
obstacles, because on the worst case we have that $|Is|=C\cdot A\cdot
|Ob|$ for
some constant $C$ that depend of the chosen density of sites per area.

In conclusion the time cost for the creation of the graph
is
\newcommand{\eqCostGraph}{\ensuremath{\bigO(|Ob|\log |Ob|)}}
\begin{equation}
  \label{eq:costGraph}
  \eqCostGraph
\end{equation}
and the number of the vertices in the graph
is 
\begin{equation}
  \label{eq:numV}
  |V|=\bigO(|Is|)=\bigO(|Ob|)
\end{equation}
because the number of vertices in the resulting graph is the
same order of number of input sites.

If we make the hypothesis of having maximum degree $k$ in $G$ -
i.e. each vertex in $V$ is connected at most to other $k$ vertices -
then we have that
\begin{equation}
  \label{eq:numE}
  |E|=\bigO(k|V|)=\bigO(k|Ob|).
\end{equation}
In the worst case $k=|V|$ and $|E|=\bigO(|V|^2)$ but for Voronoi
diagrams in plane there is a property that if we have $n$ input sites
that lay on a circumference, without any other site inside the
circumference, then the center of the circumference is a vertex shared
by $n$ cells \cite{deberg}. The same property is extensible in space with
spheres. We can make the assumption that no more than three sites can lay
on a circumference so no vertex can have more than three neighbours,
or the same with four vertices in sphere, and this assumption is
plausible because we use floating point numbers for the coordinates of
the vertices of the obstacles, and is quite improbable that more than
four points lays in a sphere. With this assumption $k$ is a constant,
and \cref{eq:numE} become
\begin{equation*}
  |E|=\bigO(|V|)=\bigO(|Ob|).
\end{equation*}

For pruning the graph of every edge that intersects obstacles we need
to solve a system of three unknowns in thre equations for every edge
and every obstacle's face\footnote{See \cref{sec:intersectionST}.}, so
we have a cost of
\newcommand{\eqCostPruning}{\ensuremath{\bigO(k|Ob|^2)}}
\begin{equation}
  \label{eq:costPruning}
  \bigO(|E|\cdot|Ob|)=\eqCostPruning
\end{equation}
and if we make the assumption of $k$ constant
\begin{equation*}
  \bigO(|Ob|^2)
\end{equation*}

\subsection{Triple's graph}\label{sec:trigraph}
Before calculating the shortest path on the chosen graph with Dijkstra
\cite{dijkstra}\cite{knuth}, we
transform it in a graph containing all the triples
of three adjacent vertices in the original graph. This because we want
to filter the triples for collisions as described in
\cref{sec:inter1}. We call the transformed graph
$$G_t=(V_t,E_t)$$
where we have triples of vertexes of $G$ in $V_t$.

The original graph $G$ is not directed and it is weighted
with the distance from vertex to vertex. The transformed graph $G_t$ is
directed and weighted, where if in $G$ the nodes $\ve{a}$
and $\ve{b}$ are
neighbouring, and the nodes $\ve{b}$ and $\ve{c}$ are neighbouring, then $G_t$
have the two nodes $(\ve{a},\ve{b},\ve{c})$ and $(\ve{c},\ve{b},\ve{a})$. In
$G_t$ a node $(\ve{a_1},\ve{b_1},\ve{c_1})$ is a predecessor of
$(\ve{a_2},\ve{b_2},\ve{c_2})$ if $\ve{b_1}=\ve{a_2}$ and $\ve{c_1}=\ve{b_2}$, and the weight of the arc
from $(\ve{a_1},\ve{b_1},\ve{c_1})$ to $(\ve{a_2},\ve{b_2},\ve{c_2})$ in $G_t$ is
equal to
the weight of the arc from $\ve{a_1}$ to $\ve{b_1}(=\ve{a_2})$ in $G$.

\begin{algo}{Create triples graph $G_t$}{alg:createTripleGraph}
  \Function{createTriplesGraph}{$G$}
  \State $V_t\Ass E_t\Ass \emptyset$
  \ForAll{$(\ve{a},\ve{b})\in E$}\label{ln:tripleFor0}
  \State $leftOut\Ass leftIn\Ass rightOut\Ass rightIn\Ass \emptyset$
  \ForAll{$\ve{v}\in N_G(\ve{a})\setminus\{\ve{b}\}$}
  \State $leftOut \Ass leftOut\cup \{(\ve{v},\ve{a},\ve{b})\}$
  \State $leftIn \Ass leftIn\cup \{(\ve{b},\ve{a},\ve{v})\}$
  \State $V_t \Ass V_t\cup \{(\ve{v},\ve{a},\ve{b}), (\ve{b},\ve{a},\ve{v})\}$
  \EndFor
  \ForAll{$\ve{v}\in N_G(\ve{b})\setminus\{\ve{a}\}$}
  \State $rightOut \Ass rightOut\cup \{(\ve{v},\ve{b},\ve{a})\}$
  \State $rightIn \Ass rightIn\cup \{(\ve{a},\ve{b},\ve{v})\}$
  \State $V_t \Ass V_t\cup \{(\ve{v},\ve{b},\ve{a}), (\ve{a},\ve{b},\ve{v})\}$
  \EndFor
  \ForAll{$\ve{o}\in leftOut$}
  \ForAll{$\ve{i}\in rightIn$}
  \State $E_t \Ass E_t\cup (\ve{o},\ve{i})$
  \EndFor
  \EndFor
  \ForAll{$\ve{o}\in rightOut$}\label{ln:tripleFor1}
  \ForAll{$\ve{i}\in leftIn$}\label{ln:tripleFor2}
  \State $E_t \Ass E_t\cup (\ve{o},\ve{i})$
  \EndFor
  \EndFor
  \EndFor
  \State $G_t\Ass(V_t,E_t)$
  \State\Return $G_t$
  \EndFunction
\end{algo}
On \cref{alg:createTripleGraph} is visible the algorithm for creating
$G_t$.

The transformation of the graph is useful only for the obstacle
avoidance algorithm of
\cref{sec:inter1}, theoretically is possible to bypass such
transformation for the algorithm on \cref{sec:inter2}.

\subsubsection{Complexity considerations}
If we suppose a maximum degree $k$ for each vertex in the graph $G$ -
i.e. each vertex in $V$ can have maximum $k$ edges attached to
it - then the number of vertices in the transformed graph $G_t$ is 
\begin{equation}
  \label{eq:numTriples}
  |V_t|\leq |V|\cdot k\cdot(k-1)=\bigO(k^2|V|)
\end{equation}
because for each vertex $\ve{v}$ in $G$ we need to
consider all the neighbours of $\ve{v}$ and the neighbours of the neighbours
of $\ve{v}$ (excluded $\ve{v}$).

For how we defined the triples neighbour rule in $G_t$ we have
that each triple is a predecessor of maximum $k-1$ other triples, for
instance $(\ve{a},\ve{b},\ve{c})$ in $V_t$ is the predecessor of all the triples
$(\ve{b},\ve{c},*)$ where $*$ can be one of the $k$ neighbours
of $\ve{c}$ in $V$ excluded $\ve{b}$. So the number of edges in $G_t$ is
\begin{equation}
  \label{eq:numEdgesTriples}
  |E_t|\leq |V_t|\cdot (k-1)=\bigO(k|V_t|)=\bigO(k^3|V|)
\end{equation}

Also the time cost for the creation of $G_t$ is
\newcommand{\eqCostVt}{\ensuremath{\bigO(k^3|Ob|)}}
\begin{equation}
  \label{eq:costVt}
  \bigO(k^2|E|)=\eqCostVt
\end{equation}
because the \cref{alg:createTripleGraph} for creating the transformed
graph scan all the edges $e$ on \cref{ln:tripleFor0} and for each
iteration
the main cost are the two for on \cref{ln:tripleFor1} and
\cref{ln:tripleFor2} scanning each one triples created from at most
$k$ neighbours
of the vertices at the extremes of $e$.

\section{Obstacle avoidance}\label{sec:obsAvoid}
Before using the polynomial chain extracted using the algorithm
explained in \cref{sec:polChain} as a control polygon for the
\bs, we need to deal with a
problem: every possible path in the graph $G$ is
free from collisions by construction - in fact we prune the graph of
every edge that intersect an obstacle - but this don't guarantees that
the curve will be free from obstacles. This concept is expressed in \cref{fig:intersect}.
\begin{myfig}{Schematic of \bs that intersect an obstacle in the plane.}{fig:intersect}
  \begin{tikzpicture}
    \path[obstacle] (1,0) -- (2,1) -- (3,0) -- (1,0);
    \draw[controlPoly] (0,0) -- (2,2) -- (4,0);
    \draw[spline] (0,0) to [bend left=40] (4,0);

    \filldraw[controlVert] (0,0) circle (2pt);
    \filldraw[controlVert] (2,2) circle (2pt);
    \filldraw[controlVert] (4,0) circle (2pt);
  \end{tikzpicture}
\end{myfig}

In this chapter we make the hypothesis of using
quadratic \bss\footnote{\bss curves with degree 2 or equivalently order 3.}, in
\cref{sec:degreeInc} it is explained how is possible to use curves with
higher degree. With this assumption we can exploit the convex hull
property explained in \cref{sec:bsplineProp} and assert that the
resulting curve is contained inside the union of all the triangles
with vertices equal to three consecutive control vertices of the control
polygon. Using that property we can resolve the problem of the
collision maintaining all the triangles in the control polygon free
from collision with the triangles that compose the faces of the
obstacles. Note that the property of convex hull of quadratic
\bss is valid also in space, so the convex hull is still composed
of planar figures - specifically of triangles - like the faces of the
obstacles. This simplify all the check for the collisions because they
are all between triangles in space and we can use the methods
described in \cref{sec:intersections}.

We designed two different algorithms for dealing with the collision
problem. The first solution described in \cref{sec:inter1} implements
a modified version of Dijkstra's
algorithm that finds the shortest path from start to end in the graph
such that all the triangles formed of consecutive points in such path
are free from collisions. The second solution described in
\cref{sec:inter2} use the classical Dijkstra's algorithm for finding
the shortest path from start to end in the graph $G$, checking later for
collisions in the triangles formed of consecutive points in such path
and when one is found some actions are taken for dealing with that.

\subsection{First solution: Dijkstra's algorithm in $G_t$}\label{sec:inter1}
The first solution of the problem exploit the graph $G_t$ obtained as
explained in \cref{sec:trigraph}. Before applying Dijkstra's algorithm
to $G_t$ all the triples are filtered checking if the
triangle composed of the vertices of a triple intersect an obstacle's
face. If a triple intersect an obstacle then is removed from the graph
and so a path cannot pass from such vertices in that order.

Note that if a triple $(\ve{a},\ve{b},\ve{c})$ is removed from $V_t$ - and
consequently also the triple $(\ve{c},\ve{b},\ve{a})$ - not necessarily this exclude
the three vertices $\ve{a}$, $\ve{b}$, $\ve{c}$ from being part of the final
polynomial chain. For instance\footnote{In the plane, this graph cannot be
  obtained using the procedure based on Voronoi diagrams explained in
  \cref{sec:voronoi}, but a similar situation is plausible
  considering Voronoi cells in space.} in
\cref{fig:exampleTriples} the triple
$(\ve{a},\ve{b},\ve{c})$ and $(\ve{c},\ve{b},\ve{a})$ will be removed from $G_t$ because
the corresponding triangle intersect the obstacle, and the path
$\ve{d}\rightarrow \ve{a}\rightarrow \ve{b}\rightarrow \ve{c}\rightarrow \ve{e}$ cannot be an
admissible path. This doesn't preclude the nodes $\ve{a}$, $\ve{b}$ and $\ve{c}$ to be part
of the final admissible path $\ve{d}\rightarrow \ve{a}\rightarrow \ve{b}\rightarrow \ve{e}\rightarrow \ve{c}\rightarrow \ve{e}$.
\begin{myfig}{Example of triples.}{fig:exampleTriples}
  \begin{tikzpicture}
    \coordinate (D) at (-1,1);
    \coordinate (A) at (0,0);
    \coordinate (B) at (2,2);
    \coordinate (C) at (4,0);
    \coordinate (E) at (3,2);
    \coordinate (F) at (5,1);
    \path[obstacle] (1,-0.5) -- (2,1) -- (3,-0.5) -- (1,-0.5);
    \draw[controlPoly] (D) -- (A) -- (B) -- (C) -- (F);
    \draw[controlPoly] (B) -- (E) -- (C);

    \filldraw[controlVert] (D) circle (2pt);
    \filldraw[controlVert] (A) circle (2pt);
    \filldraw[controlVert] (B) circle (2pt);
    \filldraw[controlVert] (C) circle (2pt);
    \filldraw[controlVert] (E) circle (2pt);
    \filldraw[controlVert] (F) circle (2pt);

    \node[above=0.5em] at (D) {$\ve{d}$};
    \node[below=0.5em] at (A) {$\ve{a}$};
    \node[above=0.5em] at (B) {$\ve{b}$};
    \node[below=0.5em] at (C) {$\ve{c}$};
    \node[above=0.5em] at (E) {$\ve{e}$};
    \node[above=0.5em] at (F) {$\ve{f}$};
  \end{tikzpicture}
\end{myfig}

On the cleaned transformed graph is possible to find the shortest path on the
triples
$$
(\ve{a_0},\ve{b_0},\ve{c_0}), (\ve{a_1},\ve{b_1},\ve{c_1}),\dots,(\ve{a_i},\ve{b_i},\ve{c_i}),\dots,(\ve{a_n},\ve{b_n},\ve{c_n})
$$
 using
an algorithm like Dijkstra, and then extracting the shortest
path on the vertices taking the central vertex $\ve{b_i}$ of every
triple $(\ve{a_i},\ve{b_i},\ve{c_i})$ of the path plus the extremes $\ve{a_0}$ and $\ve{c_n}$
of the first and last triples, obtaining
$$
\ve{a_0},\ve{b_0},\ve{b_1},\dots,\ve{b_i},\dots,\ve{b_{n-1}},\ve{b_n},\ve{c_n}.
$$

\imageDouble{scrSolution1a.png}{scrSolution1b.png}{Effects of
  application of solution one.}{fig:sol11}[
\node[imageLabel] at (0.7,0.62) {$\ve{a_1}$};
\node[imageLabel] (B) at (0.35,0.4) {$\ve{b_1}$};
\node[imageLabel] (C) at (0.2,0.4) {$\ve{c_1}$};
\node[imageLabel] (O) at (0.8,0.2) {$Obs$};
\path[imageArrow] (B) -- (0.36,0.555);
\path[imageArrow] (C) -- (0.3,0.585);
\path[imageArrow] (O) -- (0.6,0.3);
][
\node[imageLabel] (A) at (0.7,0.7) {$\ve{a_2}$};
\node[imageLabel] (B) at (0.5,0.4) {$\ve{b_2}$};
\node[imageLabel] (C) at (0.35,0.4) {$\ve{c_2}$};
\node[imageLabel] (D) at (0.2,0.4) {$\ve{d_2}$};
\node[imageLabel] (O) at (0.8,0.2) {$Obs$};
\path[imageArrow] (A) -- (0.58,0.61);
\path[imageArrow] (B) -- (0.44,0.52);
\path[imageArrow] (C) -- (0.36,0.555);
\path[imageArrow] (D) -- (0.3,0.585);
\path[imageArrow] (O) -- (0.6,0.3);
]
\imageDouble{scrSolution1a2.png}{scrSolution1b2.png}{Effects of
  application of solution one, other view point.}{fig:sol12}[
\node[imageLabel] at (0.2,0.1) {$\ve{a_1}$};
\node[imageLabel] at (0.45,0.6) {$\ve{b_1}$};
\node[imageLabel] at (0.65,0.85) {$\ve{c_1}$};
\node[imageLabel] at (0.8,0.2) {$Obs$};
][
\node[imageLabel] at (0.15,0.2) {$\ve{a_2}$};
\node[imageLabel] at (0.3,0.4) {$\ve{b_2}$};
\node[imageLabel] at (0.45,0.6) {$\ve{c_2}$};
\node[imageLabel] at (0.65,0.85) {$\ve{d_2}$};
\node[imageLabel] at (0.8,0.2) {$Obs$};
]
In \cref{fig:sol11} and \cref{fig:sol12} the effect of the
application of the first solution is shown. The triangle formed by the
vertices $\ve{a_1}$, $\ve{b_1}$, $\ve{c_1}$ on the left picture of \cref{fig:sol11}
is colliding with the obstacle $Obs$ in the back, on the right picture
there
is the path $\ve{a_2},\ve{b_2},\ve{c_2},\ve{d_2}$ obtained applying the solution, where no
triangles in the
path collides with obstacles. On \cref{fig:sol12} is visible another
point of view of pictures shown in \cref{fig:sol11}.

\subsubsection{Complexity considerations}
For each triple and each \ac{OTF} we need to solve three $3\times 3$
linear systems for the
collision check\footnote{See
  \cref{sec:intersectionsTriangleTriangle}.}, so in total
the cost is
\begin{equation*}
  \bigO(|V_t|\cdot |Ob|)
\end{equation*}
and for \cref{eq:numV} and \cref{eq:numTriples} this is equal to
\newcommand{\eqCostColl}{\ensuremath{\bigO(|Ob|^2 k^2)}}
\begin{equation}
  \label{eq:costColl}
  \eqCostColl .
\end{equation}

The cost of applying Dijkstra's algorithm\footnote{In the worst case
  where no triples are removed in the cleaning phase.} in $G_t$ is
\newcommand{\eqCostDijkstraTriples}{\ensuremath{\bigO(k^3|V|+k^2|V|\log(k^2|V|)}}
\begin{equation}
  \label{eq:costDijkstraTriples}
  \bigO(|E_t|+|V_t|\log |V_t|) = \eqCostDijkstraTriples .
\end{equation}
This cost has two special cases, if $G$ is a \emph{clique} - i.e. each
node in $V$ is connected to every other node \cite{bondy} - then $k=|V|-1$ and the
cost is
\begin{equation*}
  \bigO(|V|^4);
\end{equation*}
if $k$ is constant - i.e. doesn't grow with $|V|$ - the
cost is
\begin{equation*}
  \bigO(|V|\log|V|).
\end{equation*}
The latter case is the more plausible if we assume the hypothesis that
no more than four input sites in space (three in plane) can be on the
same sphere in space (circumference in plane), in fact in that case
every Voronoi cell cannot have a vertex with more than four edges
connected in space (three in plane) \cite{deberg}.

If we sum all the costs resumed in we obtain:
\newcommand{\eqCostTotalOne}{\ensuremath{\bigO(k^2|Ob|^2+k^3|Ob|)}}
\begin{equation}\label{eq:costTotalOne}
  \eqCostTotalOne
\end{equation}
where all the other terms are absorbed in those two. If we have $k$
constant as we said before then we have an overall cost of
\newcommand{\eqCostTotalOneK}{\ensuremath{\bigO(|Ob|^2)}}
\begin{equation}\label{eq:costTotalOneK}
  \eqCostTotalOneK
\end{equation}
That derive from the collision check control\footnote{We can improve
  this result if we divide the algorithm in two parts, we 
can construct the graph only once with the heavy cost $\bigO(|Ob|^2)$
and then using
it in different trials with different starting and ending points with
a reduced cost of $\bigO(|Ob|\log |Ob|)$
for the routing.}.

\begin{table}
  \centering
  \begin{tabular}{|l|c|r|}
    \hline
    Description&Cost&Reference\\
    \hline
    \hline
    Creation of $G$&\eqCostGraph&\cref{eq:costGraph}\\
    Pruning of $G$&\eqCostPruning&\cref{eq:costPruning}\\
    Creation of $G_t$&\eqCostVt&\cref{eq:costVt}\\
    Pruning of $G_t$&\eqCostColl&\cref{eq:costColl}\\
    Routing in $G_t$& \eqCostDijkstraTriples&\cref{eq:costDijkstraTriples}\\
    \hline
    Total&\eqCostTotalOne&\cref{eq:costTotalOne}\\
    Total ($k$ constant)&\eqCostTotalOneK&\cref{eq:costTotalOneK}\\
    \hline
  \end{tabular}
  \caption{Resume of the costs for solution one}
  \label{tab:costsSol1}
\end{table}
On \cref{tab:costsSol1} we resumed all the terms that contributes to
the total costs, and the total cost itself.

\subsection{Second solution: Dijkstra's algorithm in $G$}\label{sec:inter2}
The First solution is interesting from an algorithmic point of view,
but is not very practical because it throws all the triples that
intersect an obstacle. We tried another
solution that uses another approach: obtain the shortest path 
from the Voronoi's graph $G$ directly using Dijkstra's algorithm,
without removing any triple. On that path
- that we call $P$ in this section - we
check every triple of consecutive vertices, and if it collides with a
\ac{OTF} then we take countermeasures. For instance if the path
is composed from the vertices:
\begin{equation*}
  P=\ve{v_0},\ve{v_1},\dots,\ve{v_n}
\end{equation*}
then we check if every one of the triangles 
\begin{eqnarray*}
T_0 &=& \triangle \ve{v_0}\ve{v_1}\ve{v_2}\\
T_1 &=& \triangle \ve{v_1}\ve{v_2}\ve{v_3}\\
&\cdots&\\
T_i &=& \triangle \ve{v_i}\ve{v_{i+1}}\ve{v_{i+2}}\\
&\cdots&\\
T_{n-3} &=& \triangle \ve{v_{n-3}}\ve{v_{n-2}}\ve{v_{n-1}}\\
T_{n-2} &=& \triangle \ve{v_{n-2}}\ve{v_{n-1}}\ve{v_n}
\end{eqnarray*}
intersect one of the \ac{OTF}, where $\triangle \ve{v_i}\ve{v_j}\ve{v_k}$ denotes the
triangle with
vertices the points $\ve{v_i}$, $\ve{v_j}$ and $\ve{v_k}$.

In \cref{sec:intersectionsTriangleTriangle} we explain how to measure
if a triangle $T_1=\triangle \ve{a_1}\ve{b_1}\ve{c_1}$
collides with another triangle $T_2=\triangle \ve{a_2}\ve{b_2}\ve{c_2}$ and, when a
collision is found, how to 
obtain also the barycentric coordinates on $\ve{a_2},\ve{b_2},\ve{c_2}$ of the points
where the 
edges of $T_1$ intersect $T_2$ (or the coordinates on $\ve{a_1},\ve{b_1},\ve{c_1}$ of
the points where $T_2$ intersect $T_1$).

Consider also that $G$ is pruned from all the edges that intersect any
obstacle, so none of the edges of the triangles $T_i$ can intersect
an \ac{OTF}, and the only possibility is that an edge or
more\footnote{At most two edges for each \ac{OTF} if we ignore special
  cases.} of the
obstacles intersect a
triangle $T_i$. So for each $T_i$ we have a (possibly empty) set of points
of intersection between it and the edges of each \ac{OTF} - we call
that set $O$.
\begin{myfig}{$T_i$($=\triangle \ve{v_i}\ve{v_{i+1}}\ve{v_{i+2}}$) and the points
    $\ve{o_1},\ve{o_2},\ve{o_3}$ of intersection between it and the edges of some \ac{OTF}.}{fig:triangleIntersection}
  \begin{tikzpicture}
    \coordinate (P) at (-1,0);
    \coordinate (A) at (0,0);
    \coordinate (B) at (4,5);
    \coordinate (C) at (8,1);
    \coordinate (D) at (9,1);
    \coordinate (O1) at (barycentric cs:A=0.2,B=0.6,C=0.2);
    \coordinate (O2) at (barycentric cs:A=0.5,B=0.3,C=0.2);
    \coordinate (O3) at (barycentric cs:A=0.3,B=0.2,C=0.5);
    \coordinate (W1) at (barycentric cs:A=0.4,B=0.6,C=0.);
    \coordinate (W2) at (barycentric cs:A=0.,B=0.6,C=0.4);

    \draw[controlPoly] (A) -- (B) -- (C);
    \draw[controlPolyTract] (P) -- (A);
    \draw[controlPolyTract] (C) -- (D);
    \draw[controlPolyTractHigh] (W1) -- (W2);
    \draw[controlPolyTractHigh] (A) -- (C);

    \filldraw[controlVert] (A) circle (2pt);
    \filldraw[controlVert] (B) circle (2pt);
    \filldraw[controlVert] (C) circle (2pt);
    \filldraw[obstaclePoint] (O1) circle (2pt);
    \filldraw[obstaclePoint] (O2) circle (2pt);
    \filldraw[obstaclePoint] (O3) circle (2pt);
    \filldraw[controlVertHigh] (W1) circle (2pt);
    \filldraw[controlVertHigh] (W2) circle (2pt);

    \node[below=0.5em] at (A) {$\ve{v_i}$};
    \node[above=0.5em] at (B) {$\ve{v_{i+1}}$};
    \node[below=0.5em] at (C) {$\ve{v_{i+2}}$};
    \node[below right=0.2em] (O1n) at (O1) {$\ve{o_1}$};
    \node[below=0.2em] at (O1n) {$\scriptstyle(\equiv \ve{o_{near}})$};
    \node[left=0.2em] at (O2) {$\ve{o_2}$};
    \node[below=0.2em] at (O3) {$\ve{o_3}$};
    \node[left=0.5em] at (W1) {$\ve{w_1}$};
    \node[right=0.5em] at (W2) {$\ve{w_2}$};
  \end{tikzpicture}
\end{myfig}

In \cref{fig:triangleIntersection} we have an example of the triangle
\begin{equation*}
  T_i = \triangle \ve{v_i}\ve{v_{i+1}}\ve{v_{i+2}} 
\end{equation*}
that is
intersected by obstacles in the points
\begin{equation*}
  O = \{\ve{o_1},\ve{o_2},\ve{o_3}\}.
\end{equation*}
where each one of the points in $O$ is expressed in barycentric
coordinates of the vertices $\ve{v_i}$, $\ve{v_{i+1}}$ and $\ve{v_{i+2}}$ of the
triangle:
\begin{eqnarray*}
  O_1&=&\alpha_1 \ve{v_i}+\beta_1 \ve{v_{i+1}}+\gamma_1 \ve{v_{i+2}}\\
  O_2&=&\alpha_2 \ve{v_i}+\beta_2 \ve{v_{i+1}}+\gamma_2 \ve{v_{i+2}}\\
  O_3&=&\alpha_3 \ve{v_i}+\beta_3 \ve{v_{i+1}}+\gamma_3 \ve{v_{i+2}}
\end{eqnarray*}
where $\alpha_i+\beta_i+\gamma_i=1$ for $i=1,2,3$.

We want to deal with the collision adding vertices in the control
polygon such that consecutive triangles are free from obstacles. We
obtain this adding a control vertex $\ve{w_1}$ between $\ve{v_i}$ and $\ve{v_{i+1}}$
and $\ve{w_2}$ between $\ve{v_{i+1}}$ and $\ve{v_{i+2}}$. Also we add those two
points in a manner such that the segment $\overline{\ve{w_1}\ve{w_2}}$ is
parallel to the segment $\overline{\ve{v_i}\ve{v_{i+2}}}$ and such that
$\overline{\ve{w_1}\ve{w_2}}$ pass through the obstacle point $\ve{o_{near}}$ nearest
to $\ve{v_{i+1}}$ ($\ve{o_1}$ in \cref{fig:triangleIntersection}) keeping the
triangle $\triangle \ve{w_1}\ve{v_{i+1}}\ve{w_2}$ - and also
the degenerated triangles $\triangle \ve{v_i}\ve{w_1}\ve{v_{i+1}}$ and $\triangle
\ve{v_{i+1}}\ve{w_2}\ve{v_{i+2}}$ - free from obstacles.

When we check for collisions between a segment and a triangle we
resolve a system of three unknowns in
three equations and from the solutions we extract the barycentric
coordinates of
the point of collision. When we have all the coordinates of the points
in $O$ we can obtain $\ve{o_{near}}$ picking the one with the biggest $\beta$
and then, using the corresponding $\beta_{near}$, we can obtain
\begin{eqnarray*}
  W_1&=&\beta_{near} \ve{v_{i+1}}+(1-\beta_{near})\ve{v_i}\\
  W_2&=&\beta_{near} \ve{v_{i+1}}+(1-\beta_{near})\ve{v_{i+2}}.
\end{eqnarray*}

\imageDouble{scrSolution2a.png}{scrSolution2b.png}{Effects of application of solution two.}{fig:sol21}[
\node[imageLabel] at (0.7,0.62) {$\ve{v_i}$};
\node[imageLabel] (B) at (0.45,0.4) {$\ve{v_{i+1}}$};
\node[imageLabel] (C) at (0.2,0.4) {$\ve{v_{i+2}}$};
\node[imageLabel] (O) at (0.8,0.2) {$Obs$};
\path[imageArrow] (B) -- (0.36,0.555);
\path[imageArrow] (C) -- (0.3,0.585);
\path[imageArrow] (O) -- (0.6,0.3);
][
\node[imageLabel] (W1) at (0.75,0.7) {$\ve{w_1}$};
\node[imageLabel] (W2) at (0.2,0.4) {$\ve{w_2}$};
\node[imageLabel] (O) at (0.8,0.2) {$Obs$};
\path[imageArrow] (W1) -- (0.61,0.6);
\path[imageArrow] (W2) -- (0.31,0.58);
\path[imageArrow] (O) -- (0.6,0.3);
]
\imageDouble{scrSolution2a2.png}{scrSolution2b2.png}{Effects of
  application of solution two, other view point.}{fig:sol22}[
\node[imageLabel] at (0.2,0.1) {$\ve{v_i}$};
\node[imageLabel] at (0.43,0.6) {$\ve{v_{i+1}}$};
\node[imageLabel] at (0.62,0.85) {$\ve{v_{i+2}}$};
\node[imageLabel] at (0.8,0.2) {$Obs$};
][
\node[imageLabel] at (0.2,0.1) {$\ve{v_i}$};
\node[imageLabel] at (0.43,0.6) {$\ve{v_{i+1}}$};
\node[imageLabel] at (0.62,0.85) {$\ve{v_{i+2}}$};
\node[imageLabel] at (0.8,0.2) {$Obs$};
\node[imageLabel] (W1) at (0.25,0.3) {$\ve{w_1}$};
\node[imageLabel] (W2) at (0.5,0.75) {$\ve{w_2}$};
\path[imageArrow] (W1) -- (0.3,0.15);
\path[imageArrow] (W2) -- (0.66,0.79);
\node[imageLabel] at (0.8,0.2) {$Obs$};
]
In \cref{fig:sol21} and \cref{fig:sol22} we can see the effects of the
application of this
solution to a tract of the curve. The original tract of control
polygon are on the left pictures and, the triangle
composed of those vertices
collide with the obstacle on the back. The two new vertices $\ve{w_1}$
and $\ve{w_2}$ are added to avoid the collision.

\subsubsection{Complexity considerations}
For this solution we have still the cost for
the creation and pruning of the graph $G$, then we need to apply Dijkstra's
algorithm in $G$ for obtaining $P$ with a cost \cite{bondy}
\begin{equation*}
  \bigO(|E|+|V|\log |V|).
\end{equation*}
For \cref{eq:numV} \cref{eq:numE} that cost is equal to
\newcommand{\eqCostDijkstraG}{\ensuremath{\bigO(k|Ob|+|Ob|\log |Ob|)}}
\begin{equation}\label{eq:costDijkstraG}
  \eqCostDijkstraG
\end{equation}
and if we make the assumption of $k$ constant we have a cost
\begin{equation*}
  \bigO(|Ob|\log |Ob|).
\end{equation*}

For checking and removing the collisions in the path we need to
consider every face of obstacle in $Ob$ for every
triangle in $P$ and the cost for doing this is\footnote{If
  $\#\ac{OTF}=\bigO(|Ob|)$ - i.e. the
  number of \ac{OTF} don't grow faster than the number of obstacles.}
$\bigO(|P|\cdot|Ob|)$ where in the worst case
$|P|=\bigO(|V|)=\bigO(|Ob|)$ so in total 
\newcommand{\eqCostCleanPath}{\ensuremath{\bigO(|P|\cdot|Ob|)=\bigO(|Ob|^2)}}
\begin{equation}\label{eq:costCleanPath}
  \eqCostCleanPath
\end{equation}

Summing up all the costs we have 
\newcommand{\eqCostTotalTwo}{\ensuremath{\bigO(k|Ob|^2+|Ob|\log|Ob|)}}
\begin{equation}\label{eq:costTotalTwo}
  \eqCostTotalTwo
\end{equation}
and if we consider $k$ constant
\newcommand{\eqCostTotalTwoK}{\ensuremath{\bigO(|Ob|^2)}}
\begin{equation}\label{eq:costTotalTwoK}
  \eqCostTotalTwoK .
\end{equation}

\begin{table}
  \centering
  \begin{tabular}{|l|c|r|}
    \hline
    Description&Cost&Reference\\
    \hline
    \hline
    Creation of $G$&\eqCostGraph&\cref{eq:costGraph}\\
    Pruning of $G$&\eqCostPruning&\cref{eq:costPruning}\\
    Routing in $G$&\eqCostDijkstraG&\cref{eq:costDijkstraG}\\
    Clean path&\eqCostCleanPath&\cref{eq:costCleanPath}\\
    \hline
    Total&\eqCostTotalTwo&\cref{eq:costTotalTwo}\\
    Total ($k$ costant)&\eqCostTotalTwoK&\cref{eq:costTotalTwoK}\\
    \hline
  \end{tabular}
  \caption{Resume of the costs for solution two}
  \label{tab:costsSol2}
\end{table}
On \cref{tab:costsSol2} we resumed all the terms that contributes to
the total costs, and the total cost itself.

The cost is comparable with the one of the first solution, and also in
this case we can divide the algorithm in two parts constructing only
once $G$ with cost $\bigO(|Ob|^2)$ and then using it for different
trials with a cost $\bigO(|P|\cdot|Ob|)$.

\subsection{Third solution: simulated annealing}\label{sec:inter3}
The others solutions of \cref{sec:inter1} and \cref{sec:inter2} have two
problem in common: both reject configurations in a prudent way
considering only the control polygon, and both don't optimize neither
length nor other parameters. On this section we describe a third
approach that we considered on the project, an approach that diverge
from the topic of numerical analysis.

We can see the problem of finding the shortest path as a constrained
optimization problem where a certain configuration of the control
vertices (and
consequently the \bs) is the state of the system, and we want to
minimize both the length of the control polygon (and consequently the
\bs) and the peak in curvature and torsion of the \bs under
the constraint that the \bs must not intersect the obstacles. We
are interested in optimizing both length and curvature and torsion
peaks because we want a path that is short but also a path that is
smooth.

\subsubsection{\acf{LR} applied to the project}
We can apply the concept explained in \cref{sec:lagrangianRelaxation}
to the project.

The variable space $X$ is composed of all possible
configuration of the path, or in other words is the vector
$\ve{v}=(\ve{v_1},\dots,\ve{v_n})$ of all $n$ ordered
vertices $\ve{v_i}=(x_i,y_i)$ of the
path. The \cref{eq:opt} is formulated in the problem
\begin{equation*}
  \begin{aligned}
    & \underset{\ve{v}}{\text{minimize}}
    & & \alpha\cdot maxCurv(\ve{v})+\beta\cdot
    maxTors(\ve{v})+\gamma\cdot normLen(\ve{v}) \\
    & \text{subject to}
    & & \left|bspline(\ve{v})\cap \bigcup_{i\in I}obstacle_i\right| = 0.
  \end{aligned}
\end{equation*}
where $maxCurv(\ve{v})$ is the peak of curvature of the \bs
constructed using $\ve{v}$ as control polygon,
$maxTors(\ve{v})$ is the peak in absolute value of the torsion of
the \bs constructed using $\ve{v}$ as control polygon and
$normLen(\ve{v})$ is the length of the control polygon
$\ve{v}$ normalized as percent of the length of the initial status
after extracting the path. $\alpha$, $\beta$ and $\gamma$ are fixed
coefficients used for giving a weight in the optimization process to
the curvature peak, torsion peak and length. The normalization of
length is necessary for decoupling the weight of the length from the
length of path. Regarding the constraint, $bspline(\ve{v})$
is the set of tabulated points of the \emph{\bs} obtained as
explained in
\cref{sec:spline} and \cref{sec:bsplines}, using the path as
control polygon and
$obstacle_i$ is the area of the $i^{th}$ of $m$ obstacles, and
$I=\{1,\dots,m\}$.

We need to build now the Lagrangian function corresponding to
\cref{eq:lagrangianFun}, the constraint function is not negative, and is calculated as the
ratio
\begin{equation*}
constraint(\ve{v}) = \frac{|\{\ve{p} \in spline(\ve{v})\ |\ \exists i\in\{1,\dots,m\}
  : \ve{p}\in obstacle_i \}|}{|\{\ve{p} \in spline(\ve{v})\}|}
\end{equation*}
where the points $\ve{p}$ of the spline are calculated in a discrete form. That
function is not negative, so the Lagrangian function correspondent to
\cref{eq:lagrangianFun} is
\begin{equation}\label{eq:lagrangianFunProj}
    L_d(\ve{v},\lambda)=\alpha\cdot maxCurv(\ve{v})+\beta\cdot
    maxTors(\ve{v})+\gamma\cdot normLen(\ve{v})+\lambda\cdot constraint(\ve{v}).
\end{equation}

\subsubsection{Annealing phase}
The target of the simulated annealing phase is to find the minimum
saddle points in
the curve represented by the
\cref{eq:lagrangianFunProj}.
\begin{algo}{Annealing}{alg:annealing}
  \Procedure{annealing}{$\ve{x}$}
  \State $\lambda\Ass initialLambda$\label{alg:annealing:initialize}
  \State $T\Ass initialTemperature$
  \While{not $terminationCondition()$}\label{alg:annealing:while}
  \ForAll{number of trials}\label{alg:annealing:for}
  \State $changeLambda\Ass\True$ with $changeLambdaProb$\label{alg:annealing:lambdaProb}
  \If{$changeLambda$}
  \State $\lambda'\Ass neighbour(\lambda)$\label{alg:annealing:changeLambda}
  \State $\lambda\Ass \lambda'$ with probability $\me^{-([energy(\ve{x},\lambda)-energy(\ve{x},\lambda')]^+/T)}$
  \Else
  \State $\ve{x}'\Ass neighbour(\ve{x})$\label{alg:annealing:changeX}
  \State $\ve{x}\Ass \ve{x}'$ with probability $\me^{-([energy(\ve{x}',\lambda)-energy(\ve{x},\lambda)]^+/T)}$
  \EndIf
  \EndFor
  \State $T\Ass T\cdot warmingRatio$\label{alg:annealing:cooling}
  \EndWhile
  \EndProcedure
\end{algo}

The \cref{alg:annealing} is the annealing process, on
\cref{alg:annealing:initialize} $\lambda$ and the
temperature are initialized; the \emph{while} on
\cref{alg:annealing:while} is the main loop and the terminating
condition is given by a minimum temperature or a minimum variation of
energy between two iterations; the \emph{for} at
\cref{alg:annealing:for} repeat the annealing move for a certain
number of trials, on each iteration the algorithm probabilistically
try to make a move of the state of the system, first on
\cref{alg:annealing:lambdaProb} make a choice if moving in the
Lagrangian space or in the space of the path, after that based on that
choice try to move the system in a neighbouring state - in the
Lagrangian space at
\cref{alg:annealing:changeLambda} or in the path space at
\cref{alg:annealing:changeX} - the choice is made
probabilistically in the meaning that if the energy increase in the
Lagrangian space or decrease in the path space the probability of
choosing the new state is 1, if the energy decrease in the Lagrangian
space or increase in the path space then the new state is accepted
with a probability that is\footnote{Note that $[x]^+=\max(0,x)$.}:
$$\exp(-\frac{\Delta energy}{T}).$$
Finally at the end of every trial set,
at \cref{alg:annealing:cooling}, the temperature $T$ is cooled by
a certain factor.

The $neighbour$ function choose a neighbour of the state and is
defined depending on the input
\begin{itemize}
  \item for $\lambda$ move uniformly in a range $[-maxLambdaPert, maxLambdaPert]$;
  \item for path pick randomly one of the nodes, except the extremes,
    then pick an angle in $[0,2\pi]$ and a distance
    uniformly in a specific range.
\end{itemize}

The $energy$ function is equivalent to $L_d$ in the
\cref{eq:lagrangianFunProj}:
$$energy(\ve{x},\lambda)=\alpha\cdot maxCurv(\ve{v})+\beta\cdot
    maxTors(\ve{v})+\gamma\cdot normLen(\ve{v})+\lambda\cdot constraint(\ve{v}).$$

The annealing process
find a saddle point probabilistically increasing the energy, moving
$\lambda$ and 
decreasing the energy moving the points.


\section{Post processing}\label{sec:postPro}
The purpose of the post processing phase is to try to simplify the
path obtained in the previous phase removing useless vertices.
\section{Degree increase}\label{sec:degreeInc}
\section{Nodes selection}\label{sec:nodeSel}
\section{Complexity}
\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../dissertation"
%%% End:
